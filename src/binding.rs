/* automatically generated by rust-bindgen */
#![allow(warnings)]
pub type SAP_DOUBLE = f64;
pub type SAP_UC = ::std::os::raw::c_char;
pub type SAP_RAW = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Copy)]
pub union SAP_MAX_ALIGN_T {
    pub align_1: ::std::os::raw::c_long,
    pub align_2: f64,
    pub align_3: *mut ::std::os::raw::c_void,
    pub align_4: SAP_DOUBLE,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_SAP_MAX_ALIGN_T() {
    assert_eq!(::std::mem::size_of::<SAP_MAX_ALIGN_T>() , 8usize , concat ! (
               "Size of: " , stringify ! ( SAP_MAX_ALIGN_T ) ));
    assert_eq! (::std::mem::align_of::<SAP_MAX_ALIGN_T>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( SAP_MAX_ALIGN_T ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SAP_MAX_ALIGN_T ) ) . align_1 as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SAP_MAX_ALIGN_T ) ,
                "::" , stringify ! ( align_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SAP_MAX_ALIGN_T ) ) . align_2 as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SAP_MAX_ALIGN_T ) ,
                "::" , stringify ! ( align_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SAP_MAX_ALIGN_T ) ) . align_3 as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SAP_MAX_ALIGN_T ) ,
                "::" , stringify ! ( align_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SAP_MAX_ALIGN_T ) ) . align_4 as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SAP_MAX_ALIGN_T ) ,
                "::" , stringify ! ( align_4 ) ));
}
impl Clone for SAP_MAX_ALIGN_T {
    fn clone(&self) -> Self { *self }
}
impl Default for SAP_MAX_ALIGN_T {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union DecFloat16 {
    pub bytes: [SAP_RAW; 8usize],
    pub align: SAP_DOUBLE,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_DecFloat16() {
    assert_eq!(::std::mem::size_of::<DecFloat16>() , 8usize , concat ! (
               "Size of: " , stringify ! ( DecFloat16 ) ));
    assert_eq! (::std::mem::align_of::<DecFloat16>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( DecFloat16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DecFloat16 ) ) . bytes as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DecFloat16 ) , "::" ,
                stringify ! ( bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DecFloat16 ) ) . align as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DecFloat16 ) , "::" ,
                stringify ! ( align ) ));
}
impl Clone for DecFloat16 {
    fn clone(&self) -> Self { *self }
}
impl Default for DecFloat16 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union DecFloat34 {
    pub bytes: [SAP_RAW; 16usize],
    pub align: SAP_MAX_ALIGN_T,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_DecFloat34() {
    assert_eq!(::std::mem::size_of::<DecFloat34>() , 16usize , concat ! (
               "Size of: " , stringify ! ( DecFloat34 ) ));
    assert_eq! (::std::mem::align_of::<DecFloat34>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( DecFloat34 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DecFloat34 ) ) . bytes as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DecFloat34 ) , "::" ,
                stringify ! ( bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DecFloat34 ) ) . align as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DecFloat34 ) , "::" ,
                stringify ! ( align ) ));
}
impl Clone for DecFloat34 {
    fn clone(&self) -> Self { *self }
}
impl Default for DecFloat34 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RFC_CHAR = SAP_UC;
pub type RFC_NUM = RFC_CHAR;
pub type RFC_BYTE = SAP_RAW;
pub type RFC_INT1 = SAP_RAW;
pub type RFC_INT2 = ::std::os::raw::c_short;
pub type RFC_INT = ::std::os::raw::c_int;
pub type RFC_FLOAT = f64;
pub type RFC_DATE = [RFC_CHAR; 8usize];
pub type RFC_TIME = [RFC_CHAR; 6usize];
pub type RFC_DECF16 = DecFloat16;
pub type RFC_DECF34 = DecFloat34;
pub type RFC_TID = [SAP_UC; 25usize];
pub type RFC_UNITID = [SAP_UC; 33usize];
#[repr(u32)]
/// \enum _RFCTYPE
/// \ingroup api
///
/// RFCTYPE is used in field descriptions (#RFC_FIELD_DESC) and parameter descriptions
/// (#RFC_PARAMETER_DESC) and denotes the ABAP data type of the corresponding field/parameter.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _RFCTYPE {
    RFCTYPE_CHAR = 0,
    RFCTYPE_DATE = 1,
    RFCTYPE_BCD = 2,
    RFCTYPE_TIME = 3,
    RFCTYPE_BYTE = 4,
    RFCTYPE_TABLE = 5,
    RFCTYPE_NUM = 6,
    RFCTYPE_FLOAT = 7,
    RFCTYPE_INT = 8,
    RFCTYPE_INT2 = 9,
    RFCTYPE_INT1 = 10,
    RFCTYPE_NULL = 14,
    RFCTYPE_ABAPOBJECT = 16,
    RFCTYPE_STRUCTURE = 17,
    RFCTYPE_DECF16 = 23,
    RFCTYPE_DECF34 = 24,
    RFCTYPE_XMLDATA = 28,
    RFCTYPE_STRING = 29,
    RFCTYPE_XSTRING = 30,
    RFCTYPE_INT8 = 31,
    RFCTYPE_UTCLONG = 32,
    RFCTYPE_UTCSECOND = 33,
    RFCTYPE_UTCMINUTE = 34,
    RFCTYPE_DTDAY = 35,
    RFCTYPE_DTWEEK = 36,
    RFCTYPE_DTMONTH = 37,
    RFCTYPE_TSECOND = 38,
    RFCTYPE_TMINUTE = 39,
    RFCTYPE_CDAY = 40,
    RFCTYPE_BOX = 41,
    RFCTYPE_GENERIC_BOX = 42,
    _RFCTYPE_max_value = 43,
}
pub use self::_RFCTYPE as RFCTYPE;
#[repr(u32)]
/// \enum _RFC_RC
/// \ingroup api
///
/// RFC return codes used by all functions that do not directly return a handle.
/// Also used as error indicator in the structure #RFC_ERROR_INFO::code.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _RFC_RC {
    RFC_OK = 0,
    RFC_COMMUNICATION_FAILURE = 1,
    RFC_LOGON_FAILURE = 2,
    RFC_ABAP_RUNTIME_FAILURE = 3,
    RFC_ABAP_MESSAGE = 4,
    RFC_ABAP_EXCEPTION = 5,
    RFC_CLOSED = 6,
    RFC_CANCELED = 7,
    RFC_TIMEOUT = 8,
    RFC_MEMORY_INSUFFICIENT = 9,
    RFC_VERSION_MISMATCH = 10,
    RFC_INVALID_PROTOCOL = 11,
    RFC_SERIALIZATION_FAILURE = 12,
    RFC_INVALID_HANDLE = 13,
    RFC_RETRY = 14,
    RFC_EXTERNAL_FAILURE = 15,
    RFC_EXECUTED = 16,
    RFC_NOT_FOUND = 17,
    RFC_NOT_SUPPORTED = 18,
    RFC_ILLEGAL_STATE = 19,
    RFC_INVALID_PARAMETER = 20,
    RFC_CODEPAGE_CONVERSION_FAILURE = 21,
    RFC_CONVERSION_FAILURE = 22,
    RFC_BUFFER_TOO_SMALL = 23,
    RFC_TABLE_MOVE_BOF = 24,
    RFC_TABLE_MOVE_EOF = 25,
    RFC_START_SAPGUI_FAILURE = 26,
    RFC_ABAP_CLASS_EXCEPTION = 27,
    RFC_UNKNOWN_ERROR = 28,
    RFC_AUTHORIZATION_FAILURE = 29,
    _RFC_RC_max_value = 30,
}
pub use self::_RFC_RC as RFC_RC;
#[repr(u32)]
/// \enum _RFC_ERROR_GROUP
/// \ingroup api
///
/// Groups several error conditions together, depending on the "layer" to which they belong.
/// Used in the structure #RFC_ERROR_INFO::group.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _RFC_ERROR_GROUP {
    OK = 0,
    ABAP_APPLICATION_FAILURE = 1,
    ABAP_RUNTIME_FAILURE = 2,
    LOGON_FAILURE = 3,
    COMMUNICATION_FAILURE = 4,
    EXTERNAL_RUNTIME_FAILURE = 5,
    EXTERNAL_APPLICATION_FAILURE = 6,
    EXTERNAL_AUTHORIZATION_FAILURE = 7,
}
pub use self::_RFC_ERROR_GROUP as RFC_ERROR_GROUP;
/// \struct _RFC_ERROR_INFO
/// \ingroup api
///
/// Used in all functions of the NW RFC library to return detailed information about
/// an error that has just occurred. This can be an error that the communication partner
/// sent back to us, an error that occurred in the network layer or operating system,
/// an internal error in the NW RFC library or an error that the application programmer
/// (i.e. you) has committed...
///
/// Within a server function implementation, the application programmer (you) can return
/// this structure to the RFC library in order to specify the error type & message that
/// you want to send back to the backend.
#[repr(C)]
#[derive(Copy)]
pub struct _RFC_ERROR_INFO {
    /// < Error code. Should be the same as the API returns if the API has return type RFC_RC
    pub code: RFC_RC,
    /// < Error group
    pub group: RFC_ERROR_GROUP,
    /// < Error key
    pub key: [SAP_UC; 128usize],
    /// < Error message
    pub message: [SAP_UC; 512usize],
    /// < ABAP message ID , or class
    pub abapMsgClass: [SAP_UC; 21usize],
    /// < ABAP message type, e.g. 'E', 'A' or 'X'
    pub abapMsgType: [SAP_UC; 2usize],
    /// < ABAP message number
    pub abapMsgNumber: [RFC_NUM; 4usize],
    /// < ABAP message details field 1, corresponds to SY-MSGV1
    pub abapMsgV1: [SAP_UC; 51usize],
    /// < ABAP message details field 2, corresponds to SY-MSGV2
    pub abapMsgV2: [SAP_UC; 51usize],
    /// < ABAP message details field 3, corresponds to SY-MSGV3
    pub abapMsgV3: [SAP_UC; 51usize],
    /// < ABAP message details field 4, corresponds to SY-MSGV4
    pub abapMsgV4: [SAP_UC; 51usize],
}
#[test]
fn bindgen_test_layout__RFC_ERROR_INFO() {
    assert_eq!(::std::mem::size_of::<_RFC_ERROR_INFO>() , 880usize , concat !
               ( "Size of: " , stringify ! ( _RFC_ERROR_INFO ) ));
    assert_eq! (::std::mem::align_of::<_RFC_ERROR_INFO>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( _RFC_ERROR_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ERROR_INFO ) ) . code as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ERROR_INFO ) ,
                "::" , stringify ! ( code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ERROR_INFO ) ) . group as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ERROR_INFO ) ,
                "::" , stringify ! ( group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ERROR_INFO ) ) . key as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ERROR_INFO ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ERROR_INFO ) ) . message as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ERROR_INFO ) ,
                "::" , stringify ! ( message ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ERROR_INFO ) ) . abapMsgClass as *
                const _ as usize } , 648usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ERROR_INFO ) ,
                "::" , stringify ! ( abapMsgClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ERROR_INFO ) ) . abapMsgType as *
                const _ as usize } , 669usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ERROR_INFO ) ,
                "::" , stringify ! ( abapMsgType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ERROR_INFO ) ) . abapMsgNumber as *
                const _ as usize } , 671usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ERROR_INFO ) ,
                "::" , stringify ! ( abapMsgNumber ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ERROR_INFO ) ) . abapMsgV1 as *
                const _ as usize } , 675usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ERROR_INFO ) ,
                "::" , stringify ! ( abapMsgV1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ERROR_INFO ) ) . abapMsgV2 as *
                const _ as usize } , 726usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ERROR_INFO ) ,
                "::" , stringify ! ( abapMsgV2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ERROR_INFO ) ) . abapMsgV3 as *
                const _ as usize } , 777usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ERROR_INFO ) ,
                "::" , stringify ! ( abapMsgV3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ERROR_INFO ) ) . abapMsgV4 as *
                const _ as usize } , 828usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ERROR_INFO ) ,
                "::" , stringify ! ( abapMsgV4 ) ));
}
impl Clone for _RFC_ERROR_INFO {
    fn clone(&self) -> Self { *self }
}
impl Default for _RFC_ERROR_INFO {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RFC_ERROR_INFO = _RFC_ERROR_INFO;
/// \struct _RFC_ATTRIBUTES
/// \ingroup connection
///
/// Structure returned by RfcGetConnectionAttributes() giving some
/// information about the partner system on the other side of this RFC connection.
#[repr(C)]
#[derive(Copy)]
pub struct _RFC_ATTRIBUTES {
    /// < RFC destination
    pub dest: [SAP_UC; 65usize],
    /// < Own host name
    pub host: [SAP_UC; 101usize],
    /// < Partner host name
    pub partnerHost: [SAP_UC; 101usize],
    /// < R/3 system number
    pub sysNumber: [SAP_UC; 3usize],
    /// < R/3 system ID
    pub sysId: [SAP_UC; 9usize],
    /// < Client ("Mandant")
    pub client: [SAP_UC; 4usize],
    /// < User
    pub user: [SAP_UC; 13usize],
    /// < Language
    pub language: [SAP_UC; 3usize],
    /// < Trace level (0-3)
    pub trace: [SAP_UC; 2usize],
    /// < 2-byte ISO-Language
    pub isoLanguage: [SAP_UC; 3usize],
    /// < Own code page
    pub codepage: [SAP_UC; 5usize],
    /// < Partner code page
    pub partnerCodepage: [SAP_UC; 5usize],
    /// < C/S: RFC Client / RFC Server
    pub rfcRole: [SAP_UC; 2usize],
    /// < 2/3/E/R: R/2,R/3,Ext,Reg.Ext
    pub type_: [SAP_UC; 2usize],
    /// < 2/3/E/R: R/2,R/3,Ext,Reg.Ext
    pub partnerType: [SAP_UC; 2usize],
    /// < My system release
    pub rel: [SAP_UC; 5usize],
    /// < Partner system release
    pub partnerRel: [SAP_UC; 5usize],
    /// < Partner kernel release
    pub kernelRel: [SAP_UC; 5usize],
    /// < CPI-C Conversation ID
    pub cpicConvId: [SAP_UC; 9usize],
    /// < Name of the calling APAB program (report, module pool)
    pub progName: [SAP_UC; 129usize],
    /// < Number of bytes per character in the backend's current codepage. Note this is different from the semantics of the PCS parameter.
    pub partnerBytesPerChar: [SAP_UC; 2usize],
    /// <  Partner system code page
    pub partnerSystemCodepage: [SAP_UC; 5usize],
    /// < Reserved for later use
    pub reserved: [SAP_UC; 79usize],
}
#[test]
fn bindgen_test_layout__RFC_ATTRIBUTES() {
    assert_eq!(::std::mem::size_of::<_RFC_ATTRIBUTES>() , 559usize , concat !
               ( "Size of: " , stringify ! ( _RFC_ATTRIBUTES ) ));
    assert_eq! (::std::mem::align_of::<_RFC_ATTRIBUTES>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( _RFC_ATTRIBUTES ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . dest as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( dest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . host as * const _
                as usize } , 65usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( host ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . partnerHost as *
                const _ as usize } , 166usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( partnerHost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . sysNumber as *
                const _ as usize } , 267usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( sysNumber ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . sysId as * const _
                as usize } , 270usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( sysId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . client as * const _
                as usize } , 279usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( client ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . user as * const _
                as usize } , 283usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . language as * const
                _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( language ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . trace as * const _
                as usize } , 299usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( trace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . isoLanguage as *
                const _ as usize } , 301usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( isoLanguage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . codepage as * const
                _ as usize } , 304usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( codepage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . partnerCodepage as
                * const _ as usize } , 309usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( partnerCodepage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . rfcRole as * const
                _ as usize } , 314usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( rfcRole ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . type_ as * const _
                as usize } , 316usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . partnerType as *
                const _ as usize } , 318usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( partnerType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . rel as * const _ as
                usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( rel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . partnerRel as *
                const _ as usize } , 325usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( partnerRel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . kernelRel as *
                const _ as usize } , 330usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( kernelRel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . cpicConvId as *
                const _ as usize } , 335usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( cpicConvId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . progName as * const
                _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( progName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . partnerBytesPerChar
                as * const _ as usize } , 473usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( partnerBytesPerChar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) .
                partnerSystemCodepage as * const _ as usize } , 475usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( partnerSystemCodepage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_ATTRIBUTES ) ) . reserved as * const
                _ as usize } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_ATTRIBUTES ) ,
                "::" , stringify ! ( reserved ) ));
}
impl Clone for _RFC_ATTRIBUTES {
    fn clone(&self) -> Self { *self }
}
impl Default for _RFC_ATTRIBUTES {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RFC_ATTRIBUTES = _RFC_ATTRIBUTES;
/// \struct _RFC_SECURITY_ATTRIBUTES
/// \ingroup connection
///
/// Structure passed to the RFC_SERVER_AUTHORIZATION_HANDLER giving some
/// security related information about the calling ABAP partner of an incoming RFC call.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RFC_SECURITY_ATTRIBUTES {
    /// < Name of the called function module
    pub functionName: *mut SAP_UC,
    /// < Calling ABAP system ID
    pub sysId: *mut SAP_UC,
    /// < ABAP Client ("Mandant")
    pub client: *mut SAP_UC,
    /// < ABAP User
    pub user: *mut SAP_UC,
    /// < Name of the calling APAB program (report, module pool)
    pub progName: *mut SAP_UC,
    /// < SNC key of the calling ABAP system, if SNC is enabled
    pub sncName: *mut SAP_UC,
    /// < Logon ticket of the ABAP user, if SSO2 or assertion tickets are enabled
    pub ssoTicket: *mut SAP_UC,
}
#[test]
fn bindgen_test_layout__RFC_SECURITY_ATTRIBUTES() {
    assert_eq!(::std::mem::size_of::<_RFC_SECURITY_ATTRIBUTES>() , 56usize ,
               concat ! (
               "Size of: " , stringify ! ( _RFC_SECURITY_ATTRIBUTES ) ));
    assert_eq! (::std::mem::align_of::<_RFC_SECURITY_ATTRIBUTES>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _RFC_SECURITY_ATTRIBUTES ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_SECURITY_ATTRIBUTES ) ) .
                functionName as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_SECURITY_ATTRIBUTES ) , "::" , stringify ! ( functionName
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_SECURITY_ATTRIBUTES ) ) . sysId as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_SECURITY_ATTRIBUTES ) , "::" , stringify ! ( sysId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_SECURITY_ATTRIBUTES ) ) . client as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_SECURITY_ATTRIBUTES ) , "::" , stringify ! ( client ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_SECURITY_ATTRIBUTES ) ) . user as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_SECURITY_ATTRIBUTES ) , "::" , stringify ! ( user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_SECURITY_ATTRIBUTES ) ) . progName
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_SECURITY_ATTRIBUTES ) , "::" , stringify ! ( progName )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_SECURITY_ATTRIBUTES ) ) . sncName as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_SECURITY_ATTRIBUTES ) , "::" , stringify ! ( sncName )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_SECURITY_ATTRIBUTES ) ) . ssoTicket
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_SECURITY_ATTRIBUTES ) , "::" , stringify ! ( ssoTicket )
                ));
}
impl Clone for _RFC_SECURITY_ATTRIBUTES {
    fn clone(&self) -> Self { *self }
}
impl Default for _RFC_SECURITY_ATTRIBUTES {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RFC_SECURITY_ATTRIBUTES = _RFC_SECURITY_ATTRIBUTES;
/// \struct _RFC_UNIT_ATTRIBUTES
/// \ingroup bgrfc
///
/// If the external program is the sender of the bgRFC unit, this structure is used to set a
/// bunch of special attributes that determine, how a bgRFC Unit will be processed in the backend.
/// The fields user, client, tCode and program are optional. If left empty, the NW RFC lib will
/// fill them with default values. The fields hostname, sendingDate and sendingTime should not be
/// filled, the lib fills them, when the unit is submitted.
///
/// If the external program is the receiver of the bgRFC unit, you can use RfcGetServerContext()
/// to obtain the values that were sent by the backend.
#[repr(C)]
#[derive(Copy)]
pub struct _RFC_UNIT_ATTRIBUTES {
    /// < If != 0, the backend will write kernel traces, while executing this unit.
    pub kernelTrace: ::std::os::raw::c_short,
    /// < If != 0, the backend will write statistic records, while executing this unit.
    pub satTrace: ::std::os::raw::c_short,
    /// < If != 0, the backend will keep a "history" for this unit.
    pub unitHistory: ::std::os::raw::c_short,
    /// < Used only for type Q: If != 0, the unit will be written to the queue, but not processed. The unit can then be started manually in the ABAP debugger.
    pub lock: ::std::os::raw::c_short,
    /// < Per default the backend will check during execution of a unit, whether one of the unit's function modules triggers an explicit or implicit COMMIT WORK. In this case the unit is aborted with an error, because the transactional integrity of this unit cannot be guaranteed. By setting "noCommitCheck" to true (!=0), this behavior can be suppressed, meaning the unit will be executed anyway, even if one of it's function modules "misbehaves" and triggers a COMMIT WORK.
    pub noCommitCheck: ::std::os::raw::c_short,
    /// < Sender User (optional). Default is current operating system User.
    pub user: [SAP_UC; 13usize],
    /// < Sender Client ("Mandant") (optional). Default is "000".
    pub client: [SAP_UC; 4usize],
    /// < Sender Transaction Code (optional). Default is "".
    pub tCode: [SAP_UC; 21usize],
    /// < Sender Program (optional). Default is current executable name.
    pub program: [SAP_UC; 41usize],
    /// < Sender hostname. Used only when the external program is server. In the client case the nwrfclib fills this automatically.
    pub hostname: [SAP_UC; 41usize],
    /// < Sending date in UTC (GMT-0). Used only when the external program is server. In the client case the nwrfclib fills this automatically.
    pub sendingDate: RFC_DATE,
    /// < Sending time in UTC (GMT-0). Used only when the external program is server. In the client case the nwrfclib fills this automatically.
    pub sendingTime: RFC_TIME,
}
#[test]
fn bindgen_test_layout__RFC_UNIT_ATTRIBUTES() {
    assert_eq!(::std::mem::size_of::<_RFC_UNIT_ATTRIBUTES>() , 144usize ,
               concat ! ( "Size of: " , stringify ! ( _RFC_UNIT_ATTRIBUTES )
               ));
    assert_eq! (::std::mem::align_of::<_RFC_UNIT_ATTRIBUTES>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( _RFC_UNIT_ATTRIBUTES ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_UNIT_ATTRIBUTES ) ) . kernelTrace as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_UNIT_ATTRIBUTES )
                , "::" , stringify ! ( kernelTrace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_UNIT_ATTRIBUTES ) ) . satTrace as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_UNIT_ATTRIBUTES )
                , "::" , stringify ! ( satTrace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_UNIT_ATTRIBUTES ) ) . unitHistory as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_UNIT_ATTRIBUTES )
                , "::" , stringify ! ( unitHistory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_UNIT_ATTRIBUTES ) ) . lock as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_UNIT_ATTRIBUTES )
                , "::" , stringify ! ( lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_UNIT_ATTRIBUTES ) ) . noCommitCheck
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_UNIT_ATTRIBUTES )
                , "::" , stringify ! ( noCommitCheck ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_UNIT_ATTRIBUTES ) ) . user as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_UNIT_ATTRIBUTES )
                , "::" , stringify ! ( user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_UNIT_ATTRIBUTES ) ) . client as *
                const _ as usize } , 23usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_UNIT_ATTRIBUTES )
                , "::" , stringify ! ( client ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_UNIT_ATTRIBUTES ) ) . tCode as *
                const _ as usize } , 27usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_UNIT_ATTRIBUTES )
                , "::" , stringify ! ( tCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_UNIT_ATTRIBUTES ) ) . program as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_UNIT_ATTRIBUTES )
                , "::" , stringify ! ( program ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_UNIT_ATTRIBUTES ) ) . hostname as *
                const _ as usize } , 89usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_UNIT_ATTRIBUTES )
                , "::" , stringify ! ( hostname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_UNIT_ATTRIBUTES ) ) . sendingDate as
                * const _ as usize } , 130usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_UNIT_ATTRIBUTES )
                , "::" , stringify ! ( sendingDate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_UNIT_ATTRIBUTES ) ) . sendingTime as
                * const _ as usize } , 138usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_UNIT_ATTRIBUTES )
                , "::" , stringify ! ( sendingTime ) ));
}
impl Clone for _RFC_UNIT_ATTRIBUTES {
    fn clone(&self) -> Self { *self }
}
impl Default for _RFC_UNIT_ATTRIBUTES {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RFC_UNIT_ATTRIBUTES = _RFC_UNIT_ATTRIBUTES;
/// \struct _RFC_UNIT_IDENTIFIER
/// \ingroup bgrfc
///
/// For convenience combines a unit's ID and its type.
#[repr(C)]
#[derive(Copy)]
pub struct _RFC_UNIT_IDENTIFIER {
    /// < 'T' for "transactional" behavior (unit is executed synchronously), 'Q' for "queued" behavior (unit is written into a queue and executed asynchronously)
    pub unitType: SAP_UC,
    /// < The 32 digit unit ID of the background unit.
    pub unitID: RFC_UNITID,
}
#[test]
fn bindgen_test_layout__RFC_UNIT_IDENTIFIER() {
    assert_eq!(::std::mem::size_of::<_RFC_UNIT_IDENTIFIER>() , 34usize ,
               concat ! ( "Size of: " , stringify ! ( _RFC_UNIT_IDENTIFIER )
               ));
    assert_eq! (::std::mem::align_of::<_RFC_UNIT_IDENTIFIER>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( _RFC_UNIT_IDENTIFIER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_UNIT_IDENTIFIER ) ) . unitType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_UNIT_IDENTIFIER )
                , "::" , stringify ! ( unitType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_UNIT_IDENTIFIER ) ) . unitID as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_UNIT_IDENTIFIER )
                , "::" , stringify ! ( unitID ) ));
}
impl Clone for _RFC_UNIT_IDENTIFIER {
    fn clone(&self) -> Self { *self }
}
impl Default for _RFC_UNIT_IDENTIFIER {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RFC_UNIT_IDENTIFIER = _RFC_UNIT_IDENTIFIER;
#[repr(u32)]
/// \enum _RFC_UNIT_STATE
/// \ingroup bgrfc
///
/// Used in RfcGetUnitState() for inquiring the processing status of a background Unit that
/// we (or someone else) sent into this backend.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _RFC_UNIT_STATE {
    RFC_UNIT_NOT_FOUND = 0,
    RFC_UNIT_IN_PROCESS = 1,
    RFC_UNIT_COMMITTED = 2,
    RFC_UNIT_ROLLED_BACK = 3,
    RFC_UNIT_CONFIRMED = 4,
}
pub use self::_RFC_UNIT_STATE as RFC_UNIT_STATE;
pub type RFC_ABAP_NAME = [RFC_CHAR; 31usize];
pub type RFC_PARAMETER_DEFVALUE = [RFC_CHAR; 31usize];
pub type RFC_PARAMETER_TEXT = [RFC_CHAR; 80usize];
#[repr(u32)]
/// \enum _RFC_CALL_TYPE
/// \ingroup connection
///
/// Used in RfcGetServerContext() for inquiring the type of
/// an incoming function call from the backend.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _RFC_CALL_TYPE {
    RFC_SYNCHRONOUS = 0,
    RFC_TRANSACTIONAL = 1,
    RFC_QUEUED = 2,
    RFC_BACKGROUND_UNIT = 3,
}
pub use self::_RFC_CALL_TYPE as RFC_CALL_TYPE;
/// \struct _RFC_SERVER_CONTEXT
/// \ingroup connection
///
/// Used in RfcGetServerContext() for obtaining more information about the
/// current incoming function call.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RFC_SERVER_CONTEXT {
    /// < Specifies the type of function call. Depending on the value of this field, some of the other fields of this struct may be filled.
    pub type_: RFC_CALL_TYPE,
    /// < If type is RFC_TRANSACTIONAL or RFC_QUEUED, this field is filled with the 24 digit TID of the tRFC/qRFC unit.
    pub tid: RFC_TID,
    /// < If type is RFC_BACKGROUND_UNIT, this pointer is set to the unit identifier of the LUW. Note: the pointer is valid only during the execution context of your server function.
    pub unitIdentifier: *mut RFC_UNIT_IDENTIFIER,
    /// < If type is RFC_BACKGROUND_UNIT, this pointer is set to the unit attributes of the LUW. Note: the pointer is valid only during the execution context of your server function.
    pub unitAttributes: *mut RFC_UNIT_ATTRIBUTES,
}
#[test]
fn bindgen_test_layout__RFC_SERVER_CONTEXT() {
    assert_eq!(::std::mem::size_of::<_RFC_SERVER_CONTEXT>() , 48usize , concat
               ! ( "Size of: " , stringify ! ( _RFC_SERVER_CONTEXT ) ));
    assert_eq! (::std::mem::align_of::<_RFC_SERVER_CONTEXT>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _RFC_SERVER_CONTEXT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_SERVER_CONTEXT ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_SERVER_CONTEXT ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_SERVER_CONTEXT ) ) . tid as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_SERVER_CONTEXT ) ,
                "::" , stringify ! ( tid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_SERVER_CONTEXT ) ) . unitIdentifier
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_SERVER_CONTEXT ) ,
                "::" , stringify ! ( unitIdentifier ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_SERVER_CONTEXT ) ) . unitAttributes
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_SERVER_CONTEXT ) ,
                "::" , stringify ! ( unitAttributes ) ));
}
impl Clone for _RFC_SERVER_CONTEXT {
    fn clone(&self) -> Self { *self }
}
impl Default for _RFC_SERVER_CONTEXT {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RFC_SERVER_CONTEXT = _RFC_SERVER_CONTEXT;
/// \struct _RFC_TYPE_DESC_HANDLE
/// \ingroup repository
///
/// Handle to a cached metadata description of a structure or table type.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RFC_TYPE_DESC_HANDLE {
    pub handle: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__RFC_TYPE_DESC_HANDLE() {
    assert_eq!(::std::mem::size_of::<_RFC_TYPE_DESC_HANDLE>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( _RFC_TYPE_DESC_HANDLE )
               ));
    assert_eq! (::std::mem::align_of::<_RFC_TYPE_DESC_HANDLE>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _RFC_TYPE_DESC_HANDLE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_TYPE_DESC_HANDLE ) ) . handle as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_TYPE_DESC_HANDLE )
                , "::" , stringify ! ( handle ) ));
}
impl Clone for _RFC_TYPE_DESC_HANDLE {
    fn clone(&self) -> Self { *self }
}
impl Default for _RFC_TYPE_DESC_HANDLE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RFC_TYPE_DESC_HANDLE = *mut _RFC_TYPE_DESC_HANDLE;
/// \struct _RFC_FUNCTION_DESC_HANDLE
/// \ingroup repository
///
/// Handle to a cached metadata description of a function module.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RFC_FUNCTION_DESC_HANDLE {
    pub handle: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__RFC_FUNCTION_DESC_HANDLE() {
    assert_eq!(::std::mem::size_of::<_RFC_FUNCTION_DESC_HANDLE>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( _RFC_FUNCTION_DESC_HANDLE ) ));
    assert_eq! (::std::mem::align_of::<_RFC_FUNCTION_DESC_HANDLE>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _RFC_FUNCTION_DESC_HANDLE )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_FUNCTION_DESC_HANDLE ) ) . handle as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_FUNCTION_DESC_HANDLE ) , "::" , stringify ! ( handle )
                ));
}
impl Clone for _RFC_FUNCTION_DESC_HANDLE {
    fn clone(&self) -> Self { *self }
}
impl Default for _RFC_FUNCTION_DESC_HANDLE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RFC_FUNCTION_DESC_HANDLE = *mut _RFC_FUNCTION_DESC_HANDLE;
/// \struct _RFC_CLASS_DESC_HANDLE
/// \ingroup repository
///
/// Handle to a cached metadata description of a class.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RFC_CLASS_DESC_HANDLE {
    pub handle: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__RFC_CLASS_DESC_HANDLE() {
    assert_eq!(::std::mem::size_of::<_RFC_CLASS_DESC_HANDLE>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( _RFC_CLASS_DESC_HANDLE )
               ));
    assert_eq! (::std::mem::align_of::<_RFC_CLASS_DESC_HANDLE>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _RFC_CLASS_DESC_HANDLE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_CLASS_DESC_HANDLE ) ) . handle as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_CLASS_DESC_HANDLE
                ) , "::" , stringify ! ( handle ) ));
}
impl Clone for _RFC_CLASS_DESC_HANDLE {
    fn clone(&self) -> Self { *self }
}
impl Default for _RFC_CLASS_DESC_HANDLE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RFC_CLASS_DESC_HANDLE = *mut _RFC_CLASS_DESC_HANDLE;
/// \struct RFC_DATA_CONTAINER
/// \ingroup container
///
/// Handle to a general data container (structure, table or function module).
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RFC_DATA_CONTAINER {
    pub handle: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_RFC_DATA_CONTAINER() {
    assert_eq!(::std::mem::size_of::<RFC_DATA_CONTAINER>() , 8usize , concat !
               ( "Size of: " , stringify ! ( RFC_DATA_CONTAINER ) ));
    assert_eq! (::std::mem::align_of::<RFC_DATA_CONTAINER>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( RFC_DATA_CONTAINER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RFC_DATA_CONTAINER ) ) . handle as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RFC_DATA_CONTAINER ) ,
                "::" , stringify ! ( handle ) ));
}
impl Clone for RFC_DATA_CONTAINER {
    fn clone(&self) -> Self { *self }
}
impl Default for RFC_DATA_CONTAINER {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DATA_CONTAINER_HANDLE = *mut RFC_DATA_CONTAINER;
/// \struct RFC_STRUCTURE_HANDLE
/// \ingroup container
///
/// Handle to a data container for a structure.
pub type RFC_STRUCTURE_HANDLE = DATA_CONTAINER_HANDLE;
/// \struct RFC_FUNCTION_HANDLE
/// \ingroup container
///
/// Handle to a data container for a function module.
pub type RFC_FUNCTION_HANDLE = DATA_CONTAINER_HANDLE;
/// \struct RFC_TABLE_HANDLE
/// \ingroup container
///
/// Handle to a data container for a table.
pub type RFC_TABLE_HANDLE = DATA_CONTAINER_HANDLE;
/// \struct RFC_ABAP_OBJECT_HANDLE
/// \ingroup container
///
/// Handle to a data container for an ABAP object instance.
pub type RFC_ABAP_OBJECT_HANDLE = DATA_CONTAINER_HANDLE;
/// \struct _RFC_CONNECTION_HANDLE
/// \ingroup connection
///
/// Handle to an RFC connection (client connection or server connection).
/// Returned by RfcOpenConnection() or RfcRegisterServer().
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RFC_CONNECTION_HANDLE {
    pub handle: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__RFC_CONNECTION_HANDLE() {
    assert_eq!(::std::mem::size_of::<_RFC_CONNECTION_HANDLE>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( _RFC_CONNECTION_HANDLE )
               ));
    assert_eq! (::std::mem::align_of::<_RFC_CONNECTION_HANDLE>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _RFC_CONNECTION_HANDLE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_CONNECTION_HANDLE ) ) . handle as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_CONNECTION_HANDLE
                ) , "::" , stringify ! ( handle ) ));
}
impl Clone for _RFC_CONNECTION_HANDLE {
    fn clone(&self) -> Self { *self }
}
impl Default for _RFC_CONNECTION_HANDLE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RFC_CONNECTION_HANDLE = *mut _RFC_CONNECTION_HANDLE;
/// \struct _RFC_TRANSACTION_HANDLE
/// \ingroup transaction
///
/// Handle to a data container for a tRFC/qRFC LUW.
/// Can be filled with several RFC_FUNCTION_HANDLEs.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RFC_TRANSACTION_HANDLE {
    pub handle: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__RFC_TRANSACTION_HANDLE() {
    assert_eq!(::std::mem::size_of::<_RFC_TRANSACTION_HANDLE>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( _RFC_TRANSACTION_HANDLE ) ));
    assert_eq! (::std::mem::align_of::<_RFC_TRANSACTION_HANDLE>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _RFC_TRANSACTION_HANDLE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_TRANSACTION_HANDLE ) ) . handle as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_TRANSACTION_HANDLE
                ) , "::" , stringify ! ( handle ) ));
}
impl Clone for _RFC_TRANSACTION_HANDLE {
    fn clone(&self) -> Self { *self }
}
impl Default for _RFC_TRANSACTION_HANDLE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RFC_TRANSACTION_HANDLE = *mut _RFC_TRANSACTION_HANDLE;
/// \struct _RFC_UNIT_HANDLE
/// \ingroup bgrfc
///
/// Handle to a data container for a bgRFC LUW.
/// Can be filled with several RFC_FUNCTION_HANDLEs.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RFC_UNIT_HANDLE {
    pub handle: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__RFC_UNIT_HANDLE() {
    assert_eq!(::std::mem::size_of::<_RFC_UNIT_HANDLE>() , 8usize , concat ! (
               "Size of: " , stringify ! ( _RFC_UNIT_HANDLE ) ));
    assert_eq! (::std::mem::align_of::<_RFC_UNIT_HANDLE>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _RFC_UNIT_HANDLE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_UNIT_HANDLE ) ) . handle as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_UNIT_HANDLE ) ,
                "::" , stringify ! ( handle ) ));
}
impl Clone for _RFC_UNIT_HANDLE {
    fn clone(&self) -> Self { *self }
}
impl Default for _RFC_UNIT_HANDLE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RFC_UNIT_HANDLE = *mut _RFC_UNIT_HANDLE;
/// \struct _RFC_CONNECTION_PARAMETER
/// \ingroup connection
///
/// Structure used for connecting to a backend system via RfcOpenConnection() or
/// RfcRegisterServer(). For a list of supported parameters see these two functions or the file sapnwrfc.ini, which gives a complete list of all possible connection parameters.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RFC_CONNECTION_PARAMETER {
    /// < The name of the connection parameter, like ashost, user, client.
    pub name: *const SAP_UC,
    /// < The value of the given parameter.
    pub value: *const SAP_UC,
}
#[test]
fn bindgen_test_layout__RFC_CONNECTION_PARAMETER() {
    assert_eq!(::std::mem::size_of::<_RFC_CONNECTION_PARAMETER>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( _RFC_CONNECTION_PARAMETER ) ));
    assert_eq! (::std::mem::align_of::<_RFC_CONNECTION_PARAMETER>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _RFC_CONNECTION_PARAMETER )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_CONNECTION_PARAMETER ) ) . name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_CONNECTION_PARAMETER ) , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_CONNECTION_PARAMETER ) ) . value as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_CONNECTION_PARAMETER ) , "::" , stringify ! ( value ) ));
}
impl Clone for _RFC_CONNECTION_PARAMETER {
    fn clone(&self) -> Self { *self }
}
impl Default for _RFC_CONNECTION_PARAMETER {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RFC_CONNECTION_PARAMETER = _RFC_CONNECTION_PARAMETER;
/// \struct _RFC_FIELD_DESC
/// \ingroup repository
///
/// Structure for reading (RfcGetFieldDescByIndex() or RfcGetFieldDescByName())
/// or defining (RfcAddTypeField()) the properties of a field in a structure/table.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _RFC_FIELD_DESC {
    /// < Field name, null-terminated string
    pub name: RFC_ABAP_NAME,
    /// < Field data type
    pub type_: RFCTYPE,
    /// < Field length in bytes in a 1-byte-per-SAP_CHAR system
    pub nucLength: ::std::os::raw::c_uint,
    /// < Field offset in bytes in a 1-byte-per-SAP_CHAR system
    pub nucOffset: ::std::os::raw::c_uint,
    /// < Field length in bytes in a 2-byte-per-SAP_CHAR system
    pub ucLength: ::std::os::raw::c_uint,
    /// < Field offset in bytes in a 2-byte-per-SAP_CHAR system
    pub ucOffset: ::std::os::raw::c_uint,
    /// < If the field is of type "packed number" (BCD), this member gives the number of decimals.
    pub decimals: ::std::os::raw::c_uint,
    /// < Pointer to an RFC_STRUCTURE_DESC structure for the nested sub-type if the type field is RFCTYPE_STRUCTURE or RFCTYPE_TABLE */
    pub typeDescHandle: RFC_TYPE_DESC_HANDLE,
    /// < Not used by the NW RFC library. This parameter can be used by applications that want to store additional information in the repository (like F4 help values, e.g.).
    pub extendedDescription: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__RFC_FIELD_DESC() {
    assert_eq!(::std::mem::size_of::<_RFC_FIELD_DESC>() , 72usize , concat ! (
               "Size of: " , stringify ! ( _RFC_FIELD_DESC ) ));
    assert_eq! (::std::mem::align_of::<_RFC_FIELD_DESC>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _RFC_FIELD_DESC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_FIELD_DESC ) ) . name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_FIELD_DESC ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_FIELD_DESC ) ) . type_ as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_FIELD_DESC ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_FIELD_DESC ) ) . nucLength as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_FIELD_DESC ) ,
                "::" , stringify ! ( nucLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_FIELD_DESC ) ) . nucOffset as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_FIELD_DESC ) ,
                "::" , stringify ! ( nucOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_FIELD_DESC ) ) . ucLength as * const
                _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_FIELD_DESC ) ,
                "::" , stringify ! ( ucLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_FIELD_DESC ) ) . ucOffset as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_FIELD_DESC ) ,
                "::" , stringify ! ( ucOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_FIELD_DESC ) ) . decimals as * const
                _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_FIELD_DESC ) ,
                "::" , stringify ! ( decimals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_FIELD_DESC ) ) . typeDescHandle as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_FIELD_DESC ) ,
                "::" , stringify ! ( typeDescHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_FIELD_DESC ) ) . extendedDescription
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_FIELD_DESC ) ,
                "::" , stringify ! ( extendedDescription ) ));
}
impl Clone for _RFC_FIELD_DESC {
    fn clone(&self) -> Self { *self }
}
impl Default for _RFC_FIELD_DESC {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RFC_FIELD_DESC = _RFC_FIELD_DESC;
#[repr(u32)]
/// \enum _RFC_DIRECTION
/// \ingroup repository
///
/// Used in #RFC_PARAMETER_DESC::direction for specifying the direction of a function module parameter.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _RFC_DIRECTION {
    RFC_IMPORT = 1,
    RFC_EXPORT = 2,
    RFC_CHANGING = 3,
    RFC_TABLES = 7,
}
pub use self::_RFC_DIRECTION as RFC_DIRECTION;
/// \struct _RFC_PARAMETER_DESC
/// \ingroup repository
///
/// Structure for reading (RfcGetParameterDescByIndex() or RfcGetParameterDescByName())
/// or defining (RfcAddParameter()) the properties of a parameter in a function module.
#[repr(C)]
#[derive(Copy)]
pub struct _RFC_PARAMETER_DESC {
    /// < Parameter name, null-terminated string
    pub name: RFC_ABAP_NAME,
    /// < Parameter data type
    pub type_: RFCTYPE,
    /// < Specifies whether the parameter is an input, output or bi-directional parameter
    pub direction: RFC_DIRECTION,
    /// < Parameter length in bytes in a 1-byte-per-SAP_CHAR system
    pub nucLength: ::std::os::raw::c_uint,
    /// < Parameter length in bytes in a 2-byte-per-SAP_CHAR system
    pub ucLength: ::std::os::raw::c_uint,
    /// < Gives the number of decimals in case or a packed number (BCD)
    pub decimals: ::std::os::raw::c_uint,
    /// < Handle to the structure definition in case this parameter is a structure or table
    pub typeDescHandle: RFC_TYPE_DESC_HANDLE,
    /// < Default value as defined in SE37
    pub defaultValue: RFC_PARAMETER_DEFVALUE,
    /// < Description text of the parameter as defined in SE37. Null-terminated string.
    pub parameterText: RFC_PARAMETER_TEXT,
    /// < Specifies whether this parameter is defined as optional in SE37. 1 is optional, 0 non-optional
    pub optional: RFC_BYTE,
    /// < This field can be used by the application programmer (i.e. you) to store arbitrary extra information.
    pub extendedDescription: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__RFC_PARAMETER_DESC() {
    assert_eq!(::std::mem::size_of::<_RFC_PARAMETER_DESC>() , 184usize ,
               concat ! ( "Size of: " , stringify ! ( _RFC_PARAMETER_DESC )
               ));
    assert_eq! (::std::mem::align_of::<_RFC_PARAMETER_DESC>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _RFC_PARAMETER_DESC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_PARAMETER_DESC ) ) . name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_PARAMETER_DESC ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_PARAMETER_DESC ) ) . type_ as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_PARAMETER_DESC ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_PARAMETER_DESC ) ) . direction as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_PARAMETER_DESC ) ,
                "::" , stringify ! ( direction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_PARAMETER_DESC ) ) . nucLength as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_PARAMETER_DESC ) ,
                "::" , stringify ! ( nucLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_PARAMETER_DESC ) ) . ucLength as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_PARAMETER_DESC ) ,
                "::" , stringify ! ( ucLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_PARAMETER_DESC ) ) . decimals as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_PARAMETER_DESC ) ,
                "::" , stringify ! ( decimals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_PARAMETER_DESC ) ) . typeDescHandle
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_PARAMETER_DESC ) ,
                "::" , stringify ! ( typeDescHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_PARAMETER_DESC ) ) . defaultValue as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_PARAMETER_DESC ) ,
                "::" , stringify ! ( defaultValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_PARAMETER_DESC ) ) . parameterText
                as * const _ as usize } , 95usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_PARAMETER_DESC ) ,
                "::" , stringify ! ( parameterText ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_PARAMETER_DESC ) ) . optional as *
                const _ as usize } , 175usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_PARAMETER_DESC ) ,
                "::" , stringify ! ( optional ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_PARAMETER_DESC ) ) .
                extendedDescription as * const _ as usize } , 176usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _RFC_PARAMETER_DESC ) ,
                "::" , stringify ! ( extendedDescription ) ));
}
impl Clone for _RFC_PARAMETER_DESC {
    fn clone(&self) -> Self { *self }
}
impl Default for _RFC_PARAMETER_DESC {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RFC_PARAMETER_DESC = _RFC_PARAMETER_DESC;
/// \struct _RFC_EXCEPTION_DESC
/// \ingroup repository
///
/// Structure for reading (RfcGetExceptionDescByIndex() or RfcGetExceptionDescByName())
/// or defining (RfcAddException()) the properties of an exception key in a function module.
#[repr(C)]
#[derive(Copy)]
pub struct _RFC_EXCEPTION_DESC {
    /// < Exception key
    pub key: [SAP_UC; 128usize],
    /// < Error message (exception text as defined in SE37)
    pub message: [SAP_UC; 512usize],
}
#[test]
fn bindgen_test_layout__RFC_EXCEPTION_DESC() {
    assert_eq!(::std::mem::size_of::<_RFC_EXCEPTION_DESC>() , 640usize ,
               concat ! ( "Size of: " , stringify ! ( _RFC_EXCEPTION_DESC )
               ));
    assert_eq! (::std::mem::align_of::<_RFC_EXCEPTION_DESC>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( _RFC_EXCEPTION_DESC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_EXCEPTION_DESC ) ) . key as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_EXCEPTION_DESC ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_EXCEPTION_DESC ) ) . message as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _RFC_EXCEPTION_DESC ) ,
                "::" , stringify ! ( message ) ));
}
impl Clone for _RFC_EXCEPTION_DESC {
    fn clone(&self) -> Self { *self }
}
impl Default for _RFC_EXCEPTION_DESC {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RFC_EXCEPTION_DESC = _RFC_EXCEPTION_DESC;
#[repr(u32)]
/// \enum _RFC_CLASS_ATTRIBUTE_TYPE
/// \ingroup repository
///
/// Determines the type of an ABAP Object attribute.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _RFC_CLASS_ATTRIBUTE_TYPE {
    RFC_CLASS_ATTRIBUTE_INSTANCE = 0,
    RFC_CLASS_ATTRIBUTE_CLASS = 1,
    RFC_CLASS_ATTRIBUTE_CONSTANT = 2,
}
pub use self::_RFC_CLASS_ATTRIBUTE_TYPE as RFC_CLASS_ATTRIBUTE_TYPE;
pub type RFC_CLASS_ATTRIBUTE_DEFVALUE = [RFC_CHAR; 31usize];
pub type RFC_CLASS_NAME = [RFC_CHAR; 31usize];
pub type RFC_CLASS_ATTRIBUTE_DESCRIPTION = [RFC_CHAR; 512usize];
/// \struct _RFC_CLASS_ATTRIBUTE_DESC
/// \ingroup repository
///
/// Structure for reading (RfcGetParameterDescByIndex() or RfcGetParameterDescByName())
/// or defining (RfcAddParameter()) the properties of a parameter in a function module.
#[repr(C)]
#[derive(Copy)]
pub struct _RFC_CLASS_ATTRIBUTE_DESC {
    /// < Attribute name, null-terminated string
    pub name: RFC_ABAP_NAME,
    /// < Attribute data type
    pub type_: RFCTYPE,
    /// < Attribute length in bytes in a 1-byte-per-SAP_CHAR system
    pub nucLength: ::std::os::raw::c_uint,
    /// < Attribute length in bytes in a 2-byte-per-SAP_CHAR system
    pub ucLength: ::std::os::raw::c_uint,
    /// < Gives the number of decimals in case this attribute is a packed number (BCD)
    pub decimals: ::std::os::raw::c_uint,
    /// < Handle to the structure definition in case this attribute is a structure or table
    pub typeDescHandle: RFC_TYPE_DESC_HANDLE,
    /// < Default value as defined in SE37
    pub defaultValue: RFC_CLASS_ATTRIBUTE_DEFVALUE,
    /// < Declaring class
    pub declaringClass: RFC_CLASS_NAME,
    /// < Attribute description, null terminated, may be null
    pub description: RFC_CLASS_ATTRIBUTE_DESCRIPTION,
    /// < This attribute is read only if isReadOnly != 0
    pub isReadOnly: ::std::os::raw::c_uint,
    /// < The attribute type tells you, whether this attribute is an instance attribute, a class attribute or a constant.
    pub attributeType: RFC_CLASS_ATTRIBUTE_TYPE,
    /// < This field can be used by the application programmer (i.e. you) to store arbitrary extra information.
    pub extendedDescription: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__RFC_CLASS_ATTRIBUTE_DESC() {
    assert_eq!(::std::mem::size_of::<_RFC_CLASS_ATTRIBUTE_DESC>() , 648usize ,
               concat ! (
               "Size of: " , stringify ! ( _RFC_CLASS_ATTRIBUTE_DESC ) ));
    assert_eq! (::std::mem::align_of::<_RFC_CLASS_ATTRIBUTE_DESC>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _RFC_CLASS_ATTRIBUTE_DESC )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_CLASS_ATTRIBUTE_DESC ) ) . name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_CLASS_ATTRIBUTE_DESC ) , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_CLASS_ATTRIBUTE_DESC ) ) . type_ as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_CLASS_ATTRIBUTE_DESC ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_CLASS_ATTRIBUTE_DESC ) ) . nucLength
                as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_CLASS_ATTRIBUTE_DESC ) , "::" , stringify ! ( nucLength )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_CLASS_ATTRIBUTE_DESC ) ) . ucLength
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_CLASS_ATTRIBUTE_DESC ) , "::" , stringify ! ( ucLength )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_CLASS_ATTRIBUTE_DESC ) ) . decimals
                as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_CLASS_ATTRIBUTE_DESC ) , "::" , stringify ! ( decimals )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_CLASS_ATTRIBUTE_DESC ) ) .
                typeDescHandle as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_CLASS_ATTRIBUTE_DESC ) , "::" , stringify ! (
                typeDescHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_CLASS_ATTRIBUTE_DESC ) ) .
                defaultValue as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_CLASS_ATTRIBUTE_DESC ) , "::" , stringify ! (
                defaultValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_CLASS_ATTRIBUTE_DESC ) ) .
                declaringClass as * const _ as usize } , 87usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_CLASS_ATTRIBUTE_DESC ) , "::" , stringify ! (
                declaringClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_CLASS_ATTRIBUTE_DESC ) ) .
                description as * const _ as usize } , 118usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_CLASS_ATTRIBUTE_DESC ) , "::" , stringify ! ( description
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_CLASS_ATTRIBUTE_DESC ) ) .
                isReadOnly as * const _ as usize } , 632usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_CLASS_ATTRIBUTE_DESC ) , "::" , stringify ! ( isReadOnly
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_CLASS_ATTRIBUTE_DESC ) ) .
                attributeType as * const _ as usize } , 636usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_CLASS_ATTRIBUTE_DESC ) , "::" , stringify ! (
                attributeType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_CLASS_ATTRIBUTE_DESC ) ) .
                extendedDescription as * const _ as usize } , 640usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_CLASS_ATTRIBUTE_DESC ) , "::" , stringify ! (
                extendedDescription ) ));
}
impl Clone for _RFC_CLASS_ATTRIBUTE_DESC {
    fn clone(&self) -> Self { *self }
}
impl Default for _RFC_CLASS_ATTRIBUTE_DESC {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RFC_CLASS_ATTRIBUTE_DESC = _RFC_CLASS_ATTRIBUTE_DESC;
pub type RFC_SERVER_FUNCTION =
    ::std::option::Option<unsafe extern "C" fn(rfcHandle:
                                                   RFC_CONNECTION_HANDLE,
                                               funcHandle:
                                                   RFC_FUNCTION_HANDLE,
                                               errorInfo: *mut RFC_ERROR_INFO)
                              -> RFC_RC>;
pub type RFC_ON_CHECK_TRANSACTION =
    ::std::option::Option<unsafe extern "C" fn(rfcHandle:
                                                   RFC_CONNECTION_HANDLE,
                                               tid: *const SAP_UC) -> RFC_RC>;
pub type RFC_ON_COMMIT_TRANSACTION =
    ::std::option::Option<unsafe extern "C" fn(rfcHandle:
                                                   RFC_CONNECTION_HANDLE,
                                               tid: *const SAP_UC) -> RFC_RC>;
pub type RFC_ON_ROLLBACK_TRANSACTION =
    ::std::option::Option<unsafe extern "C" fn(rfcHandle:
                                                   RFC_CONNECTION_HANDLE,
                                               tid: *const SAP_UC) -> RFC_RC>;
pub type RFC_ON_CONFIRM_TRANSACTION =
    ::std::option::Option<unsafe extern "C" fn(rfcHandle:
                                                   RFC_CONNECTION_HANDLE,
                                               tid: *const SAP_UC) -> RFC_RC>;
pub type RFC_FUNC_DESC_CALLBACK =
    ::std::option::Option<unsafe extern "C" fn(functionName: *const SAP_UC,
                                               rfcAttributes: RFC_ATTRIBUTES,
                                               funcDescHandle:
                                                   *mut RFC_FUNCTION_DESC_HANDLE)
                              -> RFC_RC>;
pub type RFC_PM_CALLBACK =
    ::std::option::Option<unsafe extern "C" fn(rfcHandle:
                                                   RFC_CONNECTION_HANDLE,
                                               functionName: *const SAP_UC,
                                               eppBuffer: *mut SAP_RAW,
                                               eppBufferSize: usize,
                                               eppLength: *mut usize)
                              -> RFC_RC>;
pub type RFC_ON_CHECK_UNIT =
    ::std::option::Option<unsafe extern "C" fn(rfcHandle:
                                                   RFC_CONNECTION_HANDLE,
                                               identifier:
                                                   *const RFC_UNIT_IDENTIFIER)
                              -> RFC_RC>;
pub type RFC_ON_COMMIT_UNIT =
    ::std::option::Option<unsafe extern "C" fn(rfcHandle:
                                                   RFC_CONNECTION_HANDLE,
                                               identifier:
                                                   *const RFC_UNIT_IDENTIFIER)
                              -> RFC_RC>;
pub type RFC_ON_ROLLBACK_UNIT =
    ::std::option::Option<unsafe extern "C" fn(rfcHandle:
                                                   RFC_CONNECTION_HANDLE,
                                               identifier:
                                                   *const RFC_UNIT_IDENTIFIER)
                              -> RFC_RC>;
pub type RFC_ON_CONFIRM_UNIT =
    ::std::option::Option<unsafe extern "C" fn(rfcHandle:
                                                   RFC_CONNECTION_HANDLE,
                                               identifier:
                                                   *const RFC_UNIT_IDENTIFIER)
                              -> RFC_RC>;
pub type RFC_ON_GET_UNIT_STATE =
    ::std::option::Option<unsafe extern "C" fn(rfcHandle:
                                                   RFC_CONNECTION_HANDLE,
                                               identifier:
                                                   *const RFC_UNIT_IDENTIFIER,
                                               unitState: *mut RFC_UNIT_STATE)
                              -> RFC_RC>;
pub type RFC_ON_PASSWORD_CHANGE =
    ::std::option::Option<unsafe extern "C" fn(sysId: *const SAP_UC,
                                               user: *const SAP_UC,
                                               client: *const SAP_UC,
                                               password: *mut SAP_UC,
                                               passwordLength:
                                                   ::std::os::raw::c_uint,
                                               newPassword: *mut SAP_UC,
                                               newPasswordLength:
                                                   ::std::os::raw::c_uint,
                                               cause: *mut RFC_ERROR_INFO)
                              -> RFC_RC>;
pub type RFC_ON_AUTHORIZATION_CHECK =
    ::std::option::Option<unsafe extern "C" fn(rfcHandle:
                                                   RFC_CONNECTION_HANDLE,
                                               secAttributes:
                                                   *mut RFC_SECURITY_ATTRIBUTES,
                                               errorInfo: *mut RFC_ERROR_INFO)
                              -> RFC_RC>;
extern "C" {
    /// \brief  Initialization of internal variables
/// \ingroup general
///
/// Sets up the internal state of the sapnwrfc library and initially reads
/// and evaluates the sapnwrfc.ini file. In case the content or location of
/// the sapnwrfc.ini file changes later on, reload it via RfcReloadIniFile().
/// %RfcInit() no longer needs to be called explicitly. The RFC library does
/// this automatically on DLL load.
/// \return RFC_RC
    pub fn RfcInit() -> RFC_RC;
}
extern "C" {
    /// \brief  Get information about currently loaded sapnwrfc library.
/// \ingroup general
///
/// Fills the provided unsigneds with the SAP release values, e.g. *majorVersion = 7,
/// *minorVersion = 10, *patchLevel = 42.
/// \out *majorVersion
/// \out *minorVersion
/// \out *patchLevel
/// \return Version information in string format.
/// \warning Don't free the returned SAP_UC pointer, it's static memory...
    pub fn RfcGetVersion(majorVersion: *mut ::std::os::raw::c_uint,
                         minorVersion: *mut ::std::os::raw::c_uint,
                         patchLevel: *mut ::std::os::raw::c_uint)
     -> *const SAP_UC;
}
extern "C" {
    /// \brief  Sets the directory in which to search for the sapnwrfc.ini file.
/// \ingroup general
///
/// By default the sapnwrfc library searches for the sapnwrfc.ini in the current
/// working directory of the process. If you want to keep it in a different directory,
/// use this function to tell the sapnwrfc library about the new path.
/// \note After you have changed the directory, the NW RFC lib automatically loads
/// the contents of the new sapnwrfc.ini file from that directory.
///
/// \in *pathName The full (absolute) path of the directory, in which the sapnwrfc
/// library should look for the sapnwrfc.ini file. A path relative to the current
/// working directory of the process also works.
/// \out *errorInfo Detail information in case anything goes wrong.
/// \return RFC_RC
    pub fn RfcSetIniPath(pathName: *const SAP_UC,
                         errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Loads the contents of the sapnwrfc.ini file into memory.
/// \ingroup general
///
/// Searches the directory given by RfcSetIniPath() (or the current working directory)
/// for the file sapnwrfc.ini and loads its contents into memory.
///
/// \out *errorInfo Detail information in case anything goes wrong. Note: if a file
/// with the name sapnwrfc.ini does not exist in the given directory, this is not
/// considered an error! Default settings are used in this case.
/// \return RFC_RC
    pub fn RfcReloadIniFile(errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the current trace level of the specified RFC connection or destination to the new value.
/// \ingroup general
///
/// \note If both of connection and destination are NULL, this function sets the "global"
/// trace level. See below.
/// \in connection A handle to a currently open RFC connection (client or server connection).
/// The new trace level will be effective immediately.
/// \in *destination Null-terminated string specifying a client or server destination as defined
/// via a DEST=... entry in sapnwrfc.ini. The new trace level will be used for new connections
/// to that destination opened after the %RfcSetTraceLevel() call. Already existing connections to
/// that destination will not be effected.
/// \in traceLevel The new trace level. Must be between 0 and 3. The meaning of those four values
/// is as follows:
/// - 0: Off. Only severe errors are logged to the dev_rfc.trc file.
/// - 1: Brief. All API calls (except for the setter and getter functions) and important attributes
/// like codepages, RFC headers, logon parameters are traced. Trace is written to a file named
/// rfc&lt;pid&gt;.trc or rfc&lt;pid&gt;_&lt;tid&gt;.trc, depending on whether tracing is done
/// on a "per-process" basis or a "per-thread" basis. &lt;pid&gt; is the current process ID,
/// &lt;tid&gt; the current thread ID.
/// - 2: Verbose. In addition to 1, the values of the "scalar" RFC parameters as well as the contents
/// of the network containers are traced. Scalar parameters are primitive types (CHAR, INT, FLOAT, etc)
/// and flat structures.
/// - 3: Full. In addition to 2 the contents of nested structures and tables as well as all API calls
/// of setter and getter functions are traced.
/// \out *errorInfo Detail information in case the specified connection or destination does not exist.
/// \return RFC_OK, RFC_INVALID_HANDLE or RFC_INVALID_PARAMETER
///
/// \note In general RFC trace can be activated/deactivated in 6 different ways:
/// - By setting the parameter RFC_TRACE=[0|1|2|3] in the DEFAULT section of the sapnwrfc.ini file.
/// This value applies to all destinations, for which no explicit trace level has been set.
/// ("Global" trace level.)
/// - By setting the parameter TRACE=[0|1|2|3] in a specific destination section of sapnwrfc.ini.
/// it applies to that destination only and overrules the "global" trace level from the DEFAULT section.
/// - By setting the environment variable RFC_TRACE=[0|1|2|3]. This overrules the setting from the
/// DEFAULT section of sapnwrfc.ini.
/// - Via %RfcSetTraceLevel(). If connection and destination are NULL, this function sets the global
/// trace level and overrules the value from the DEFAULT section of sapnwrfc.ini as well as the environment
/// variable RFC_TRACE. If connection is non-NULL, it sets the trace level for the current connection only,
/// and if destination is non-NULL, it sets the trace level for that destination, overruling the value from
/// this destination's section in the sapnwrfc.ini file.
/// - By passing a {name=TRACE, value=[0|1|2|3]} pair in the RFC_CONNECTION_PARAMETER array used in
/// RfcOpenConnection(), RfcRegisterServer() or RfcStartServer(). If that RFC_CONNECTION_PARAMETER array
/// also contains a {name=DEST, value=...} pair, the trace parameter from the array overrules the value
/// from this destination's sapnwrfc.ini section.
/// - In case the program is a server program: by activating the trace flag for the corresponding destination
/// in SM59. The trace setting on backend side is then "inherited" by the external side.
///
/// \note For more information on trace settings see the sample sapnwrfc.ini file contained in the demo folder.
    pub fn RfcSetTraceLevel(connection: RFC_CONNECTION_HANDLE,
                            destination: *mut SAP_UC,
                            traceLevel: ::std::os::raw::c_uint,
                            errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Changes the character encoding to be used in trace files.
/// \ingroup general
///
/// This function has the same effect as the sapnwrfc.ini parameter RFC_TRACE_ENCODING.
/// See the documentation of that parameter in the sample ini file contained in the
/// /demo directory of the NW RFC SDK.
///
/// \note This API call affects only new trace files that will be opened after the call.
/// The character encoding of already existing trace files is not changed in order to
/// prevent confusion and garbage data...
///
///
/// \in *traceEncoding The new encoding. Possible values are "UTF-16", "UTF-8" and
/// "DEFAULT". On Windows UTF-16 is recommended for faster performance. "DEFAULT" corresponds
/// to the operating system's default character encoding, which is CP1252 or ISO-8859-1 on
/// most Windows systems and UTF-8 on most Linux systems.
/// \out *errorInfo Detail information in case of an invalid traceEncoding input.
/// \return RFC_RC
    pub fn RfcSetTraceEncoding(traceEncoding: *mut SAP_UC,
                               errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Changes the directory where the NW RFC lib should write trace files.
/// \ingroup general
///
/// This function has the same effect as the sapnwrfc.ini parameter RFC_TRACE_DIR.
/// See the documentation of that parameter in the sample ini file contained in the
/// /demo directory of the NW RFC SDK.
///
/// \note This API call affects only new trace files that will be opened after the call.
/// The directory of already existing trace files is not changed in order to
/// prevent confusion and garbage data...
///
///
/// \in *traceDir The new directory. Can be an absolute or relative path name.
/// The directory needs to exist prior to calling this API. The NW RFC lib will not
/// attempt to create non-existing directories.
/// \out *errorInfo Detail information in case of an invalid traceEncoding input.
/// \return RFC_RC
    pub fn RfcSetTraceDir(traceDir: *mut SAP_UC,
                          errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Changes the way the NW RFC lib writes trace files.
/// \ingroup general
///
/// This function has the same effect as the sapnwrfc.ini parameter RFC_TRACE_TYPE.
/// See the documentation of that parameter in the sample ini file contained in the
/// /demo directory of the NW RFC SDK.
///
/// \note This API call closes currently open trace files and then changes to
/// "one file per process" or one "file per thread".
/// If the NW RFC lib is already using the given trace type, it does nothing.
///
///
/// \in *traceType Must be either "PROCESS" or "THREAD".
/// \out *errorInfo Detail information in case of an invalid traceEncoding input.
/// \return RFC_RC
    pub fn RfcSetTraceType(traceType: *mut SAP_UC,
                           errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Converts data in UTF-8 format to SAP_UC strings.
/// \ingroup general
///
/// \in *utf8 Pointer to UTF-8 data to be converted
/// \in utf8Length Number of bytes to convert
/// \out *sapuc Pre-allocated output buffer, which will receive the result. Output will be null-terminated.
/// \inout *sapucSize Needs to be filled with the size of the given output buffer in SAP_UC characters.
/// If the given buffer turns out to be too small (return code RFC_BUFFER_TOO_SMALL), it will be filled
/// with the required buffer size that would be necessary to convert the given input data.
/// \out *resultLength If the output buffer was large enough, resultLength will be filled with the
/// length of the output string in SAP_UC characters.
/// \out *errorInfo Will be filled with additional error information in case of an error.
/// \return RFC_RC
    pub fn RfcUTF8ToSAPUC(utf8: *const RFC_BYTE,
                          utf8Length: ::std::os::raw::c_uint,
                          sapuc: *mut SAP_UC,
                          sapucSize: *mut ::std::os::raw::c_uint,
                          resultLength: *mut ::std::os::raw::c_uint,
                          errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Converts data in SAP_UC format to UTF-8 format
/// \ingroup general
///
/// \in *sapuc Pointer to SAP_UC data to be converted
/// \in sapucLength Number of characters to convert
/// \out *utf8 Pre-allocated output buffer, which will receive the result. Output will be null-terminated.
/// \inout *utf8Size Needs to be filled with the size of the given output buffer in bytes.
/// If the given buffer turns out to be too small (return code RFC_BUFFER_TOO_SMALL), it will be filled
/// with the required buffer size that would be necessary to convert the given input data.
/// \out *resultLength If the output buffer was large enough, resultLength will be filled with the
/// length of the output string in bytes.
/// \out *errorInfo Will be filled with additional error information in case of an error.
/// \return RFC_OK or RFC_BUFFER_TOO_SMALL
    pub fn RfcSAPUCToUTF8(sapuc: *const SAP_UC,
                          sapucLength: ::std::os::raw::c_uint,
                          utf8: *mut RFC_BYTE,
                          utf8Size: *mut ::std::os::raw::c_uint,
                          resultLength: *mut ::std::os::raw::c_uint,
                          errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Converts an RFC_RC return code to a human readable string for logging purposes.
/// \ingroup general
///
/// \in rc Return code to covert to string
/// \return String representation of the return code
/// \warning Don't free the returned SAP_UC pointer -- its's static memory...
    pub fn RfcGetRcAsString(rc: RFC_RC) -> *const SAP_UC;
}
extern "C" {
    /// \brief  Converts an RFCTYPE data type indicator to a human readable string for logging purposes.
/// \ingroup general
///
/// \in type Data type indicator to convert
/// \return String representation of the type
/// \warning Don't free the returned SAP_UC pointer -- its's static memory...
    pub fn RfcGetTypeAsString(type_: RFCTYPE) -> *const SAP_UC;
}
extern "C" {
    /// \brief  Converts an RFC_DIRECTION direction indicator to a human readable string for logging purposes.
/// \ingroup general
///
/// \in direction Direction indicator to convert
/// \return String representation of the direction
/// \warning Don't free the returned SAP_UC pointer -- its's static memory...
    pub fn RfcGetDirectionAsString(direction: RFC_DIRECTION) -> *const SAP_UC;
}
extern "C" {
    /// \brief  Converts a 2-char SAP language code to the 1-char SAP language code.
/// \ingroup general
///
/// \in *laiso Pointer to the 2-char array with SAP LAISO code to convert
/// \out *lang Pointer to the 1 char for SAP SPRAS key
/// \out *errorInfo Will be filled with additional error information in case of an error.
/// \return RFC_RC RFC_OK or RFC_INVALID_PARAMETER in case of an error
/// \warning The SAP LAISO code is not 100% ISO639_1 compliant - see also ABAP table T002X columns SPRAS/LAISO for details
    pub fn RfcLanguageIsoToSap(laiso: *const SAP_UC, lang: *mut SAP_UC,
                               errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Converts a 1-char SAP language key to the 2-char SAP language code.
/// \ingroup general
///
/// \in *lang Pointer to the 1 char with SAP SPRAS key to convert
/// \out *laiso Pointer to the 2-char array for SAP LAISO code
/// \out *errorInfo Will be filled with additional error information in case of an error.
/// \return RFC_RC RFC_OK or RFC_INVALID_PARAMETER in case of an error
/// \warning The SAP LAISO code is not 100% ISO639_1 compliant - see also ABAP table T002X columns SPRAS/LAISO for details
    pub fn RfcLanguageSapToIso(lang: *const SAP_UC, laiso: *mut SAP_UC,
                               errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Opens an RFC client connection for invoking ABAP function modules in an R/3 backend.
/// \ingroup connection
///
/// Opens a client connection to an SAP System. The connectionParams may contain the following name-value pairs:
/// - client, user, passwd, lang, trace
///
/// and additionally one of
/// -# Direct application server logon: ashost, sysnr.
/// -# Logon with load balancing: mshost, msserv, sysid, group.\n
/// msserv is needed only, if the service of the message server is
/// not defined as sapms<SYSID> in /etc/services.
///
/// When logging on with SNC, user&passwd are to be replaced by
/// - snc_qop, snc_myname, snc_partnername and optionally snc_lib.
///
/// (If snc_lib is not specified, the RFC library uses the "global" GSS library
/// defined via environment variable SNC_LIB.)
///
/// When logging on with SSO Ticket, you can use mysapsso2 instead of user&passwd.
/// The old SSO format (mysapsso) is no longer supported.
///
/// Alternatively the connection parameters can be defined in the config file
/// sapnwrfc.ini. In this case you just pass the parameter dest=... and all
/// parameters that are missing in the sapnwrfc.ini entry into %RfcOpenConnection().
///
/// For a complete list of logon parameters to be used in connectionParams as well as in the
/// sapnwrfc.ini file, see the sample sapnwrfc.ini file in the SDK's demo folder.
///
/// If the logon was ok, %RfcOpenConnection() returns a client connection handle, which can be used in RfcInvoke().
/// Otherwise the return value is NULL and errorInfo contains a detailed error description.
/// errorInfo->code will be one of:
/// - RFC_INVALID_PARAMETER			One of the connectionParams was invalid
/// - RFC_COMMUNICATION_FAILURE		Something is wrong with the network or network settings
/// - RFC_LOGON_FAILURE				Invalid user/password/ticket/certificate
/// - RFC_ABAP_RUNTIME_FAILURE		Something is wrong with the R/3 backend
/// - RFC_MEMORY_INSUFFICIENT		A malloc failed when trying to allocate a temporary buffer
///
///
/// \in *connectionParams An array of RFC_CONNECTION_PARAMETERs with the names as described above
/// and the values as necessary in your landscape.
/// \in paramCount Number of parameters in the above array.
/// \out *errorInfo Returns more error details, if the connect attempt fails.
/// \return A handle to an RFC client connection that can be used for invoking ABAP function modules in the backend.
    pub fn RfcOpenConnection(connectionParams:
                                 *const RFC_CONNECTION_PARAMETER,
                             paramCount: ::std::os::raw::c_uint,
                             errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_CONNECTION_HANDLE;
}
extern "C" {
    /// \brief  Registers a server connection at an SAP gateway.
/// \ingroup connection
///
/// The connectionParams may contain the following name-value pairs:
/// - gwhost, gwserv, program_id, trace, and the parameters for SNC communication as in RfcOpenConnection().
///
/// Program_id corresponds to an RFC destination in SM59 of type "T" in registration mode.
///
/// For a complete list of logon parameters to be used in connectionParams as well as in the
/// sapnwrfc.ini file, see the sample sapnwrfc.ini file in the SDK's demo folder.
///
/// If the connection registration was ok, %RfcRegisterServer() returns a server connection handle, which can
/// be used in RfcListenAndDispatch().
/// Otherwise the return value is NULL and errorInfo contains information similar to the RfcOpenConnection() case.
///
///
/// \in *connectionParams An array of RFC_CONNECTION_PARAMETERs with the names as described above
/// and the values as necessary in your landscape.
/// \in paramCount Number of parameters in the above array.
/// \out *errorInfo Returns more error details, if the connect attempt fails.
/// \return A handle to an RFC server connection that can be used for listening for function module requests from the backend.
    pub fn RfcRegisterServer(connectionParams:
                                 *const RFC_CONNECTION_PARAMETER,
                             paramCount: ::std::os::raw::c_uint,
                             errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_CONNECTION_HANDLE;
}
extern "C" {
    /// \brief  Allows a program to be used as an RFC server which is started by the backend on demand.
/// \ingroup connection
///
/// This API needs to be called, if the server program is to be started by the R/3 application server.
/// (RFC destination in SM59 of type "T" in startup mode.)
/// argc and argv are the inputs of the mainU function. The R/3 application server passes the correct command line to
/// the program, when starting it up, so you only need to forward these two parameters to %RfcStartServer().
/// connectionParams is optional and is only needed, if you want to add additional logon parameters to the
/// ones coming from the command line, e.g for activating trace.
///
/// Like RfcRegisterServer(), the function returns a server connection handle that can be used in RfcListenAndDispatch().
/// The mechanism of this kind of RFC destination thus works as follows:
/// -# The R/3 application server opens a telnet connection to the host, where your server program is located, and
/// starts the program with the necessary logon parameters. (Or creates a child process, if the startup
/// method is "Start on application server".)
/// -# Your server program calls RfcStartServer, which opens an RFC connection back to the R/3 system.
/// -# The R/3 system then makes the function call over that RFC connection.
///
/// The main differences of "startup mode" compared to the "registration mode" are:
/// - Advantage: no logon parameters need to be maintained in the server program. (Unless you want to open
/// an additional client connection for looking up function module metadata (RFC_FUNCTION_DESC_HANDLEs) in the
/// R/3 DDIC.)
/// - Disadvantage: every single function call creates a new process and a telnet connection in addition to
/// the actual RFC connection.
///
///
/// \in argc From mainU() (command line supplied by backend)
/// \in **argv From mainU() (command line supplied by backend)
/// \in *connectionParams May optionally contain additional logon parameters
/// \in paramCount Length of the connection parameter array above
/// \out *errorInfo Returns more error details, if the connect attempt fails.
/// \return A handle to an RFC server connection that can be used for listening for function module requests from the backend.
    pub fn RfcStartServer(argc: ::std::os::raw::c_int, argv: *mut *mut SAP_UC,
                          connectionParams: *const RFC_CONNECTION_PARAMETER,
                          paramCount: ::std::os::raw::c_uint,
                          errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_CONNECTION_HANDLE;
}
extern "C" {
    /// \brief  Closes an RFC connection
/// \ingroup connection
///
/// Can be used to close client connections as well as server connections, when they are no longer needed.
///
///
/// \in rfcHandle Connection to be closed
/// \out *errorInfo Error details in case closing the connection fails. (Can usually be ignored...)
/// \return RFC_RC
    pub fn RfcCloseConnection(rfcHandle: RFC_CONNECTION_HANDLE,
                              errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Checks an RFC connection
/// \ingroup connection
///
/// Can be used to check whether a client/server connection has already been closed,
/// or whether the NW RFC library still "considers" the connection to be open.
/// Note that this does not guarantee that the connection is indeed still alive:
/// A firewall may silently have closed the connection without notifying the endpoints.
/// If you want to find out, whether the connection is still alive, you'll have to
/// use the more expensive RfcPing().
///
///
/// \in rfcHandle Connection to be checked
/// \out *isValid 1, if the connection is still found in the internal connection management, 0 otherwise.
/// \out *errorInfo Error details in case the connection is invalid.
/// \return RFC_RC
    pub fn RfcIsConnectionHandleValid(rfcHandle: RFC_CONNECTION_HANDLE,
                                      isValid: *mut ::std::os::raw::c_int,
                                      errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  RFC_RC SAP_API RfcResetServerContext
/// \ingroup connection
///
/// Resets the SAP server context ("user context / ABAP session context") associated with the given client
/// connection, but does not close the connection.
///
///
/// \in rfcHandle The client connection, whose server context is to be reset.
/// \out *errorInfo Error details in case resetting the server context fails. (Better close the connection in that case.)
/// \return RFC_RC
    pub fn RfcResetServerContext(rfcHandle: RFC_CONNECTION_HANDLE,
                                 errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Ping the remote communication partner through the passed connection handle.
/// \ingroup connection
///
/// Sends a ping to the backend in order to check, whether the connection is still alive.
/// Can be used on both, client connections as well as server connections.
/// \warning Do not use inside a server function implementation.
///
///
/// \in rfcHandle The connection to check
/// \out *errorInfo More error details in case the connection is broken.
/// \return RFC_RC
    pub fn RfcPing(rfcHandle: RFC_CONNECTION_HANDLE,
                   errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns details about the current client or server connection.
/// \ingroup connection
///
/// Consider that in case you are a server and call RfcListenAndDispatch(), the partner fields
/// of the attributes will be cleared. The reason is, although we might be only connected to a
/// gateway of one application server, the function module can be also called from the other
/// application servers of the system if configured accordingly in the SM59 destination.
///
/// I.e. expect only valid partner information from within a function module. Outside of the
/// function module, e.g. in the loop where RfcListenAndDispatch is called, you will get
/// cleared partner information in most of the cases except case RFC_OK, which means that you
/// were just called by an application server.
///
/// See documentation of RFC_ATTRIBUTES.
///
///
/// \in rfcHandle RFC connection
/// \out *attr Information about the current connection and the communication partner on the other side.
/// \out *errorInfo Additional error information (e.g. connection already closed).
/// \return RFC_RC
    pub fn RfcGetConnectionAttributes(rfcHandle: RFC_CONNECTION_HANDLE,
                                      attr: *mut RFC_ATTRIBUTES,
                                      errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Inside a server function, returns details about the current execution context.
/// \ingroup connection
///
/// See documentation of RFC_SERVER_CONTEXT.
///
///
/// \in rfcHandle RFC server connection
/// \out *context Information about the current server execution context.
/// \out *errorInfo Additional error information (e.g. connection is not a server connection).
/// \return RFC_RC
    pub fn RfcGetServerContext(rfcHandle: RFC_CONNECTION_HANDLE,
                               context: *mut RFC_SERVER_CONTEXT,
                               errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Gets the partner's SSO2 ticket, if any.
/// \ingroup connection
///
/// Can be used only with a server connection inside the implementation of a server function.
///
///
/// \in rfcHandle RFC server connection
/// \out *ssoTicket Pre-allocated buffer, which will receive the backend user's SSO2 ticket (signed user information in base64 format)
/// \inout *length Needs to be filled with the buffer length of ssoTicket. The return value will be the string
/// length of the returned ticket (if buffer was large enough) or the required buffer size (if RFC_BUFFER_TOO_SMALL).
/// \out *errorInfo More error details in case there is no ticket.
/// \return RFC_RC
/// \warning
    pub fn RfcGetPartnerSSOTicket(rfcHandle: RFC_CONNECTION_HANDLE,
                                  ssoTicket: *mut SAP_UC,
                                  length: *mut ::std::os::raw::c_uint,
                                  errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Gets the partner's SNC name, if any.
/// \ingroup connection
///
///
/// \in rfcHandle RFC server connection. If this function is executed on a client connection, RFC_ILLEGAL_STATE will be returned.
/// \out *sncName Pre-allocated buffer, which will receive the backend user's SNC name (null-terminated string).
/// \in length Size of the pre-allocated buffer. This information is coming from the GSS library, therefore
/// unfortunately the feature of assigning the used/required length to an output parameter is not possible in this case.
/// The maximum length of an SNC name is 256.
/// \out *errorInfo More error details in case SNC is not active.
/// \return RFC_RC
    pub fn RfcGetPartnerSNCName(rfcHandle: RFC_CONNECTION_HANDLE,
                                sncName: *mut SAP_UC,
                                length: ::std::os::raw::c_uint,
                                errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Gets partner's SNC key, if any.
/// \ingroup connection
///
///
/// \in rfcHandle RFC server connection. If this function is executed on a client connection, RFC_ILLEGAL_STATE will be returned.
/// \out *sncKey Pre-allocated buffer, which will receive the backend user's SNC key.
/// \inout *length Needs to be filled with the buffer length of ssoTicket. The return value will be the byte
/// length of the returned key (if buffer was large enough). Unfortunately in case of RFC_BUFFER_TOO_SMALL
/// the required size is not returned by the GSS library.
/// The maximum length of an SNC key is 1024.
/// \out *errorInfo More error details in case SNC is not active.
/// \return RFC_RC
    pub fn RfcGetPartnerSNCKey(rfcHandle: RFC_CONNECTION_HANDLE,
                               sncKey: *mut SAP_RAW,
                               length: *mut ::std::os::raw::c_uint,
                               errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Converts SNC name to SNC key.
/// \ingroup connection
///
///
/// \in *sncLib Optional: file name of the GSS library to be used for the conversion. If not specified, the
/// "global" GSS library (environment variable SNC_LIB) will be used.
/// \in *sncName Null-terminated SNC name to be converted.
/// \out *sncKey Pre-allocated buffer, which will receive the corresponding SNC key.
/// \inout *keyLength Needs to be filled with the buffer length of sncKey. The return value will be byte length
/// of the SNC key (if buffer was large enough). Unfortunately in case of RFC_BUFFER_TOO_SMALL
/// the required size is not returned by the GSS library.
/// The maximum length of an SNC key is 1024.
/// \out *errorInfo More error details in case something goes wrong.
/// \return RFC_RC
    pub fn RfcSNCNameToKey(sncLib: *const SAP_UC, sncName: *const SAP_UC,
                           sncKey: *mut SAP_RAW,
                           keyLength: *mut ::std::os::raw::c_uint,
                           errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Converts SNC key to SNC name.
/// \ingroup connection
///
///
/// \in *sncLib Optional: file name of the GSS library to be used for the conversion. If not specified, the
/// "global" GSS library (environment variable SNC_LIB) will be used.
/// \in *sncKey SNC key to be converted.
/// \in keyLength Byte length of the given SNC key
/// \out *sncName Pre-allocated buffer, which will receive the corresponding (null-terminated) SNC name.
/// \in nameLength Size of the given sncName buffer. (The maximum length of an SNC name is 256.)
/// \out *errorInfo More error details in case something goes wrong.
/// \return RFC_RC
    pub fn RfcSNCKeyToName(sncLib: *const SAP_UC, sncKey: *const SAP_RAW,
                           keyLength: ::std::os::raw::c_uint,
                           sncName: *mut SAP_UC,
                           nameLength: ::std::os::raw::c_uint,
                           errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Listens on a server connection handle and waits for incoming RFC calls from the R/3 system.
/// \ingroup connection
///
/// The mechanism for dispatching incoming function calls works as follows:
/// First %RfcListenAndDispatch() checks, whether for the current combination of R/3 SystemID and function
/// module name a callback function has been installed via RfcInstallServerFunction(). If not, it checks,
/// whether a callback function for SystemID=NULL has been installed via RfcInstallServerFunction().If not,
/// it checks, whether a global callback function has been installed via RfcInstallGenericServerFunction().
///
/// If a callback function has been found, the RFC call will be dispatched to that function for processing,
/// and %RfcListenAndDispatch() returns the return code of the callback function.
/// Otherwise %RfcListenAndDispatch() returns a SYSTEM_FAILURE to the R/3 backend and the return code
/// RFC_NOT_FOUND to the caller.
///
/// In general the return codes of %RfcListenAndDispatch() have the following meaning:
/// - RFC_OK\n		A function call was processed successfully.
/// - RFC_RETRY\n	No function call came in within the specified timeout period. ("timeout" is given in seconds.)
/// - RFC_ABAP_EXCEPTION\n	A function call was processed and ended with a defined ABAP Exception, which has
/// been returned to the backend.
///
/// In the above three cases "rfcHandle" is still open and can be used to listen for the next request.
///
/// - RFC_ABAP_MESSAGE\n	A function call was started to be processed, but was aborted with an ABAP A-, E- or X-Message.
/// The message parameters have been returned to the backend (and can be evaluated there via
/// the sy-msgid, sy-msgtype, sy-msgno, sy-msgv1, ..., sy-msgv4 parameters).
/// - RFC_EXTERNAL_FAILURE\n	A function call was started to be processed, but was aborted with a "SYSTEM_FAILURE",
/// which has been returned to the backend.
/// - RFC_COMMUNICATION_FAILURE\n	The connection broke down while processing the function call. No response
/// has been sent to the backend.
/// - RFC_CLOSED\n	The connection has been closed by the backend side (SMGW, SM04). No response
/// has been sent to the backend.
/// - RFC_NOT_FOUND\n	No handler has been found for the current function module name. A SYSTEM_FAILURE has
/// been returned to the R/3 backend.
///
/// In these five cases the connection has been closed, so the "rfcHandle" needs to be refreshed via RfcRegisterServer.
///
/// - RFC_INVALID_HANDLE\n	"rfcHandle" is invalid or points to a connection that has already been closed.
///
///
/// \in rfcHandle Server connection on which to listen for incoming requests.
/// \in timeout Number of seconds to wait for an incoming request.
/// \out *errorInfo Additional error information.
/// \return RFC_RC
    pub fn RfcListenAndDispatch(rfcHandle: RFC_CONNECTION_HANDLE,
                                timeout: ::std::os::raw::c_int,
                                errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Executes a function module in the backend system.
/// \ingroup connection
///
/// The return codes have the following meaning:
/// - RFC_OK\n		The function call was executed successfully.
/// - RFC_ABAP_EXCEPTION\n	The function call was executed and ended with a defined ABAP Exception. The key of the
/// exception can be obtained from errorInfo->key.
///
/// In the above two cases "rfcHandle" is still open and can be used to execute further function call.
///
/// - RFC_ABAP_MESSAGE\n	The function call was started to be processed, but was aborted with an ABAP Message.
/// The message parameters can be obtained from errorInfo->abapMsgClass, errorInfo->abapMsgType,
/// errorInfo->abapMsgNumber, errorInfo->abapMsgV1, ..., errorInfo->abapMsgV4.
/// - RFC_ABAP_RUNTIME_FAILURE\n	The function call was started to be processed, but was aborted with a SYSTEM_FAILURE
/// (e.g division by zero, unhandled exception, etc in the backend system).
/// Details can be obtained from errorInfo->message.
/// - RFC_COMMUNICATION_FAILURE\n	The connection broke down while processing the function call.
/// Details can be obtained from errorInfo->message.
///
/// In these three cases the connection has been closed, so the "rfcHandle" needs to be refreshed via RfcOpenConnection.
///
/// - RFC_INVALID_HANDLE\n	"rfcHandle" is invalid or points to a connection that has already been closed.
///
///
/// \in rfcHandle Client connection over which to execute the function module.
/// \inout funcHandle Data container containing the input data for the function module.
/// %RfcInvoke() will write the FM's output data into this container.
/// \out *errorInfo Additional error information.
/// \return RFC_RC
    pub fn RfcInvoke(rfcHandle: RFC_CONNECTION_HANDLE,
                     funcHandle: RFC_FUNCTION_HANDLE,
                     errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Retrieves a unique 24-digit transaction ID from the backend.
/// \ingroup transaction
///
///
/// \in rfcHandle Client connection to a backend.
/// \out tid Will be filled with the transaction ID.
/// \out *errorInfo Error information in case there is a problem with the connection.
/// \return RFC_RC
    pub fn RfcGetTransactionID(rfcHandle: RFC_CONNECTION_HANDLE,
                               tid: *mut SAP_UC,
                               errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Creates a container for executing a (multi-step) transactional call.
/// \ingroup transaction
///
/// If queueName is NULL, tRFC will be used, otherwise qRFC. Use RfcInvokeInTransaction() to
/// add one (or more) function modules to the transactional call. When sending this transactional
/// call to the backend via RfcSubmitTransaction(), the backend will then treat
/// all function modules in the RFC_TRANSACTION_HANDLE as one LUW.
///
/// \in rfcHandle Client connection to the backend, into which you want to send this tRFC/qRFC LUW.
/// \in tid A unique 24 character ID.
/// \in *queueName For tRFC set this to NULL, for qRFC specify the name of a qRFC inbound queue in the backend.
/// \out *errorInfo Error information in case there is a problem with the connection.
/// \return A data container that can be filled with several function modules.
    pub fn RfcCreateTransaction(rfcHandle: RFC_CONNECTION_HANDLE,
                                tid: *mut SAP_UC, queueName: *const SAP_UC,
                                errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_TRANSACTION_HANDLE;
}
extern "C" {
    /// \brief  Adds a function module call to a transaction. Can be used multiple times on one tHandle.
/// \ingroup transaction
///
/// \in tHandle A transaction handle created via RfcCreateTransaction().
/// \in funcHandle An RFC_FUNCTION_HANDLE, whose IMPORTING, CHANGING and TABLES parameters have been filled.
/// \note that tRFC/qRFC calls have no return values, so the EXPORTING parameters of this function handle will
/// not be filled, nor will the changes to the CHANGING/TABLES parameters be returned.
/// \out *errorInfo Actually there is nothing that can go wrong here except for invalid handles and out of memory.
/// \return RFC_RC
    pub fn RfcInvokeInTransaction(tHandle: RFC_TRANSACTION_HANDLE,
                                  funcHandle: RFC_FUNCTION_HANDLE,
                                  errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Executes the entire LUW in the backend system as an "atomic unit".
/// \ingroup transaction
///
/// This step can be repeated until it finally succeeds (RFC_OK). The transaction handling in the backend
/// system protects against duplicates (until you remove the TID from the backend's status tables using
/// RfcConfirmTransaction()).
///
///
/// \in tHandle A transaction handle filled with one or several function modules.
/// \out *errorInfo Additional error information in case anything goes wrong.
/// \return RFC_RC
    pub fn RfcSubmitTransaction(tHandle: RFC_TRANSACTION_HANDLE,
                                errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Removes the TID contained in the RFC_TRANSACTION_HANDLE from the backend's ARFCRSTATE table.
/// \ingroup transaction
///
/// After RfcSubmitTransaction() has finally succeeded, call %RfcConfirmTransaction() to clean up the
/// transaction handling table in the backend.
/// \warning Attention: after this call, the backend is no longer protected against this TID. So another
/// RfcSubmitTransaction() with the same transaction handle would result in a duplicate.
///
///
/// \in tHandle A transaction handle that has successfully been submitted.
/// \out *errorInfo Additional error information in case of a network problem.
/// \warning You may retry the Confirm step, if you get an error here, but do not retry the Submit step!
/// \return RFC_RC
    pub fn RfcConfirmTransaction(tHandle: RFC_TRANSACTION_HANDLE,
                                 errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Releases the memory of the transaction container.
/// \ingroup transaction
///
///
/// \in tHandle A transaction handle that is no longer needed.
/// \out *errorInfo Not much that can go wrong here...
/// \return RFC_RC
    pub fn RfcDestroyTransaction(tHandle: RFC_TRANSACTION_HANDLE,
                                 errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Create a 32 digit bgRFC unit ID.
/// \ingroup bgrfc
///
/// This function fills the given RFC_UNITID with a 32 digit hexadecimal GUID and zero-terminates it.
/// If you want the GUID to be generated by the backend, pass a valid rfcHandle, if you want the
/// NW RFC library to generate one locally (using the appropriate OS functions), pass NULL as
/// connection handle. In both cases the GUID is suitable for sending bgRFC units into an SAP system.
///
///
/// \in rfcHandle An open RFC connection into the system that is to create the unit ID, or NULL.
/// \out uid Preallocated buffer that will receive the 32 digits of the unit ID and a terminating zero.
/// \out *errorInfo Not much that can go wrong here...
/// \return RFC_RC
    pub fn RfcGetUnitID(rfcHandle: RFC_CONNECTION_HANDLE, uid: *mut SAP_UC,
                        errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Create a bgRFC unit.
/// \ingroup bgrfc
///
/// Creates a data container that can later be filled with one or more function modules comprising the
/// bgRFC unit. The backend will execute these function modules as an atomic unit.
/// The connection handle specifies the target system, to which the unit will later be sent. The unit ID
/// has been created in the previous step (or is an old one in case of retrying a failed unit).
/// Via queueNames and queueNameCount you can specify the list of bgRFC queues, into which this unit
/// shall later be inserted. If no queues are given (queueNameCount == 0), a synchronous unit is created
/// (type 'T') that will later be executed immediately. Otherwise an asynchronous unit (type 'Q') is created,
/// which will be inserted into the named queues and executed asynchronously by the bgRFC scheduler.
///
///
/// \in rfcHandle An open RFC connection into the system that will later receive the unit.
/// \in uid A 32 digit unique identifier of the unit.
/// \in *queueNames[] A list of bgRFC queues in the backend or NULL.
/// \in queueNameCount The length of the queueNames list.
/// \in *unitAttr A set of attributes that specify the behaviour of the unit in the backend.
/// See RFC_UNIT_ATTRIBUTES for more information.
/// \out *identifier This identifier can be used in later calls to RfcConfirmUnit() and RfcGetUnitState().
/// It is important that these functions are called with the correct unit type ('T' or 'Q'), otherwise
/// the backend system won't find the status information corresponding to the uid... Therefore the
/// NW RFC lib bundles the uid and the correct unit type here for your convenience.
/// \out *errorInfo More details in case something goes wrong.
/// \return RFC_OK or RFC_MEMORY_INSUFFICIENT
    pub fn RfcCreateUnit(rfcHandle: RFC_CONNECTION_HANDLE, uid: *mut SAP_UC,
                         queueNames: *mut *const SAP_UC,
                         queueNameCount: ::std::os::raw::c_uint,
                         unitAttr: *const RFC_UNIT_ATTRIBUTES,
                         identifier: *mut RFC_UNIT_IDENTIFIER,
                         errorInfo: *mut RFC_ERROR_INFO) -> RFC_UNIT_HANDLE;
}
extern "C" {
    /// \brief  Adds a function module to a bgRFC unit.
/// \ingroup bgrfc
///
/// Serializes the payload of the function module data container into bgRFC format and inserts
/// it into the data container for the bgRFC unit. The funcHandle can afterwards be freed
/// using RfcDestroyFunction(), because the data is copied, not referenced.
///
/// \note Despite the name "invoke", nothing is executed in the backend system, yet!
///
///
/// \in unitHandle A valid (unsubmitted) bgRFC unit, to which the given function module shall be added.
/// \in funcHandle A function module, whose payload (IMPORTING/CHANGING/TABLES) shall be added to the unit.
/// \out *errorInfo More details in case something goes wrong.
/// \return RFC_OK, RFC_INVALID_HANDLE or RFC_MEMORY_INSUFFICIENT
    pub fn RfcInvokeInUnit(unitHandle: RFC_UNIT_HANDLE,
                           funcHandle: RFC_FUNCTION_HANDLE,
                           errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Executes a bgRFC unit in the backend.
/// \ingroup bgrfc
///
/// Sends the bgRFC unit into the backend, where it will be executed synchronously or persisted
/// in the given inbound queues and executed asynchronously by the bgRFC scheduler, depending on
/// whether the unit type is 'T' or 'Q'.
/// If the type is 'T', this function will wait until the unit is completely executed and then
/// return the success or error information. If the type is 'Q', this function only inserts the
/// unit into the specified queues and then returns. Processing of the unit in the backend system
/// happens asynchronously. The return code of this function indicates, whether the unit could
/// be persisted in the given queues successfully. In order to get information about the processing
/// status of the unit, use RfcGetUnitState() at a later point.
///
/// \note Despite the name "invoke", nothing is executed in the backend system, yet!
///
///
/// \in unitHandle A valid (unsubmitted) bgRFC unit, which shall be sent into the backend system.
/// \out *errorInfo More details in case something goes wrong.
/// \return RFC_OK, RFC_INVALID_HANDLE, RFC_MEMORY_INSUFFICIENT, RFC_COMMUNICATION_FAILURE
    pub fn RfcSubmitUnit(unitHandle: RFC_UNIT_HANDLE,
                         errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Removes the UID from the backend's status management.
/// \ingroup bgrfc
///
/// After RfcSubmitUnit() returned successfully, you should use this function to cleanup
/// the status information for this unit on backend side. However, be careful: if you have
/// a three-tier architecture, don't bundle Submit and Confirm into one single logical step.
/// Otherwise you run the risk, that the middle tier (the NW RFC lib) successfully executes
/// both, the Submit and the Confirm, but on the way back to the first tier an error occurs
/// and the first tier can not be sure that the unit was really executed in the backend and
/// therefore decides to re-execute it. This will now result in a duplicate execution in the
/// backend, because the Confirm step in the first try has already deleted the UID in the
/// backend, and consequently the backend is no longer protected against re-execution of this
/// UID. In a three-tier architecture, the first tier should trigger both steps separately:
/// first the Submit, and after it knows that the Submit was successful, the Confirm.
/// Also in case the Confirm runs into an error, do NOT execute the Submit again, never!
/// You may try the Confirm again at a later point, but otherwise just ignore the error.
/// Better a left-over entry in the status information table than a duplicate unit...
///
/// \in rfcHandle A connection into the same system, into which the corresponding bgRFC unit
/// has been sent via RfcSubmitUnit().
/// \in *identifier The correct combination of UID and type of the unit. Best use the output
/// you get from RfcCreateUnit().
/// \out *errorInfo More details in case something goes wrong.
/// \return RFC_OK, RFC_INVALID_HANDLE, RFC_COMMUNICATION_FAILURE
    pub fn RfcConfirmUnit(rfcHandle: RFC_CONNECTION_HANDLE,
                          identifier: *mut RFC_UNIT_IDENTIFIER,
                          errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Releases the memory of the bgRFC unit container.
/// \ingroup bgrfc
///
///
/// \in unitHandle A unit handle that is no longer needed.
/// \out *errorInfo Not much that can go wrong here...
/// \return RFC_RC
    pub fn RfcDestroyUnit(unitHandle: RFC_UNIT_HANDLE,
                          errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Retrieves the processing status of the given background unit from the backend system's status management.
/// \ingroup bgrfc
///
///
/// \in rfcHandle A connection into the same system, into which the corresponding bgRFC unit
/// has been sent via RfcSubmitUnit().
/// \in *identifier The correct combination of UID and type of the unit. Best use the output
/// you get from RfcCreateUnit().
/// \out *state The state of the unit. See RFC_UNIT_STATE for more details.
/// \out *errorInfo Not much that can go wrong here...
/// \return RFC_RC
    pub fn RfcGetUnitState(rfcHandle: RFC_CONNECTION_HANDLE,
                           identifier: *mut RFC_UNIT_IDENTIFIER,
                           state: *mut RFC_UNIT_STATE,
                           errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Installs a callback function of type RFC_SERVER_FUNCTION, which will be triggered when a request for
/// the function module corresponding to funcDescHandle comes in from the R/3 system corresponding to sysId.
/// \ingroup installer
///
/// If you pass NULL as "sysId", the serverFunction will be used for calls from any backend system.
///
/// The main inputs of RFC_SERVER_FUNCTION are as follows:
/// - RFC_CONNECTION_HANDLE\n		A connection handle, which can be used to query logon information about
/// the current (backend) user or to make callbacks into the backend.
/// - RFC_FUNCTION_HANDLE\n			A data container that represents the current function call. Read the importing
/// parameters, which came from the backend, from this container via the RfcGetX functions and
/// write the exporting parameters, which are to be returned to the backend, into this container
/// using the RfcSetX functions.\n
/// The memory of that container is automatically released by the RFC Runtime after the
/// RFC_SERVER_FUNCTION returns.
/// - RFC_ERROR_INFO*\n			If you want to return an ABAP Exception or ABAP Message to the backend, fill the
/// parameters of that container and return RFC_ABAP_EXCEPTION or RFC_ABAP_MESSAGE from
/// your RFC_SERVER_FUNCTION implementation.\n
/// If you want to return a SYSTEM_FAILURE to the backend, fill the message parameter of
/// this container and return RFC_EXTERNAL_FAILURE from your RFC_SERVER_FUNCTION implementation.
/// If your RFC_SERVER_FUNCTION implementation processed the function call successfully, you should return RFC_OK.
///
///
/// \in *sysId System ID of the R/3 system, for which this function module implementation shall be used.
/// If you set this to NULL, this server function will be used for calls from all backends, for whose SysID no
/// explicit server function has been installed.
/// \in funcDescHandle A function description giving the name of the function module and its parameters.\n
/// Note that the NW RFC library does not create a copy of this function description. So if you are using
/// self-defined (hard-coded) function descriptions (see RfcCreateFunctionDesc()), then you need to make
/// sure, that these function descriptions are not destroyed as long as they are still used in a server
/// function installation!
/// \in serverFunction Pointer to a C function of type RFC_SERVER_FUNCTION. If you pass a null-pointer here,
/// any previously installed server function for the given function module will be uninstalled.
/// \out *errorInfo Not much that can go wrong here.
/// \return RFC_RC
    pub fn RfcInstallServerFunction(sysId: *const SAP_UC,
                                    funcDescHandle: RFC_FUNCTION_DESC_HANDLE,
                                    serverFunction: RFC_SERVER_FUNCTION,
                                    errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Installs a generic callback function of type RFC_SERVER_FUNCTION together with a callback
/// function of type RFC_FUNC_DESC_CALLBACK for obtaining the metadata description of unknown function modules.
/// \ingroup installer
///
/// The RFC Runtime calls the callback function RFC_SERVER_FUNCTION, if it receives a function call, for whose
/// function module name no matching callback function has been installed via RfcInstallServerFunction()
/// (neither for the current system ID nor for SysID=NULL).
///
/// In addition to the handler function you need to provide a second callback function: RFC_FUNC_DESC_CALLBACK.
/// The RFC runtime calls it to obtain an RFC_FUNCTION_DESC_HANDLE for the current function module from you.
/// So this function either needs to return hardcoded meta data or needs to be able to perform a DDIC lookup
/// using a valid client connection and RfcGetFunctionDesc(). If your implementation of RFC_FUNC_DESC_CALLBACK
/// is not able to provide a function description for the current function module name, it should return RFC_NOT_FOUND.
/// The RFC runtime will then notify the backend, that this function module cannot be processed by your
/// RFC server.
///
///
/// \in serverFunction A pointer to a function that can handle "all" function modules.
/// \in funcDescProvider A pointer to a function that can provide metadata descriptions of "all" function modules.
/// \out *errorInfo Again not much that can go wrong at this point.
/// \return
    pub fn RfcInstallGenericServerFunction(serverFunction:
                                               RFC_SERVER_FUNCTION,
                                           funcDescProvider:
                                               RFC_FUNC_DESC_CALLBACK,
                                           errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Installs the necessary callback functions for processing incoming tRFC/qRFC calls.
/// \ingroup installer
///
/// These functions need to be implemented by you and will be used by the RFC runtime in the following way:
/// -# The RFC_ON_CHECK_TRANSACTION function is called when a local transaction is starting. Since a transactional
/// RFC call can be issued many times by the client system, the function is responsible for storing the transaction ID
/// in permanent storage. The return value should be one of the following:
/// - RFC_OK\n		Transaction ID stored, transaction can be started.
/// - RFC_EXECUTED\n	This transaction has already been processed successfully in an earlier attempt. Skip the execution now.
/// - RFC_EXTERNAL_FAILURE\n Currently unable to access my permanent storage. Raise an exception in the sending system, so
/// that the sending system will try to resend the transaction at a later time.
/// -# The next step will be the execution of the RFC_SERVER_FUNCTIONs for all function modules contained in the LUW.
/// -# If one of the RFC_SERVER_FUNCTION implementations returns an error code, RFC_ON_ROLLBACK_TRANSACTION is called.
/// Here you should roll back all the work of all the previous RFC_SERVER_FUNCTIONs. (The easiest way is to do
/// a database ROLLBACK WORK here.)\n
/// If all RFC_SERVER_FUNCTIONs complete successfully, RFC_ON_COMMIT_TRANSACTION is called at the end.
/// Persist all the changes here (e.g. do a COMMIT WORK).\n
/// Note: Normally you'll only have "one-function-module LUWs", e.g. IDocs. In this case the RFC_SERVER_FUNCTION
/// can already commit/rollback its own work, before returning RFC_OK or an error code. So the two functions
/// RFC_ON_ROLLBACK_TRANSACTION and RFC_ON_COMMIT_TRANSACTION can be empty in this case.
/// -# In the end RFC_ON_CONFIRM_TRANSACTION will be called. All information stored about that transaction can now be
/// discarded by the server, as it no longer needs to protect itself against duplicates.
/// In general this function can be used to delete the transaction ID from permanent storage.
///
/// If you pass NULL as "sysId", the transaction handlers will be used for tRFC calls from any backend system,
/// for which no explicit handlers have been installed.
///
///
/// \in *sysId System ID of the SAP system for which to use this set of transaction handlers, or NULL.
/// \in onCheckFunction Pointer to a function of type RFC_ON_CHECK_TRANSACTION.
/// \in onCommitFunction Pointer to a function of type RFC_ON_COMMIT_TRANSACTION.
/// \in onRollbackFunction Pointer to a function of type RFC_ON_ROLLBACK_TRANSACTION.
/// \in onConfirmFunction Pointer to a function of type RFC_ON_CONFIRM_TRANSACTION.
/// \out *errorInfo Additional information, in case the handlers could not be installed.
/// \return RFC_RC
    pub fn RfcInstallTransactionHandlers(sysId: *const SAP_UC,
                                         onCheckFunction:
                                             RFC_ON_CHECK_TRANSACTION,
                                         onCommitFunction:
                                             RFC_ON_COMMIT_TRANSACTION,
                                         onRollbackFunction:
                                             RFC_ON_ROLLBACK_TRANSACTION,
                                         onConfirmFunction:
                                             RFC_ON_CONFIRM_TRANSACTION,
                                         errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Installs the necessary callback functions for processing incoming bgRFC calls.
/// \ingroup installer
///
/// These functions need to be implemented by you and will be used by the RFC runtime in the following way:
/// -# The RFC_ON_CHECK_UNIT function is called when a local background unit is starting. Since a background
/// RFC call can be issued many times by the client system, the function is responsible for storing the unit ID
/// and type in permanent storage. The return value should be one of the following:
/// - RFC_OK\n		Unit ID stored, LUW can be started.
/// - RFC_EXECUTED\n	This LUW has already been processed successfully in an earlier attempt. Skip the execution now.
/// - RFC_EXTERNAL_FAILURE\n Currently unable to access my permanent storage. Raise an exception in the sending system, so
/// that the sending system will try to resend the unit at a later time.
/// -# The next step will be the execution of the RFC_SERVER_FUNCTIONs for all function modules contained in the LUW.
/// -# If one of the RFC_SERVER_FUNCTION implementations returns an error code, RFC_ON_ROLLBACK_UNIT is called.
/// Here you should roll back all the work of all the previous RFC_SERVER_FUNCTIONs. (The easiest way is to do
/// a database ROLLBACK WORK here.)\n
/// If all RFC_SERVER_FUNCTIONs complete successfully, RFC_ON_COMMIT_UNIT is called at the end.
/// Persist all the changes here (e.g. do a COMMIT WORK).\n
/// Note: Normally you'll only have "one-function-module LUWs", e.g. IDocs. In this case the RFC_SERVER_FUNCTION
/// can already commit/rollback its own work, before returning RFC_OK or an error code. So the two functions
/// RFC_ON_ROLLBACK_UNIT and RFC_ON_COMMIT_UNIT can be empty in this case.
/// -# In the end RFC_ON_CONFIRM_UNIT will be called. All information stored about that LUW can now be
/// discarded by the server, as it no longer needs to protect itself against duplicates.
/// In general this function can be used to delete the unit ID from permanent storage.
/// -# At various points in the processing of a background unit, the backend system may or may not inquire
/// the status of the currently (or previously) processed unit by calling RFC_ON_GET_UNIT_STATE. Your implementation
/// of this function should check your permanent storage for status information about the given unit ID and
/// fill the RFC_UNIT_STATE* accordingly.
///
/// If you pass NULL as "sysId", the transaction handlers will be used for bgRFC calls from any backend system,
/// for which no explicit handlers have been installed.
///
///
/// \in *sysId System ID of the SAP system for which to use this set of transaction handlers, or NULL.
/// \in onCheckFunction Pointer to a function of type RFC_ON_CHECK_UNIT.
/// \in onCommitFunction Pointer to a function of type RFC_ON_COMMIT_UNIT.
/// \in onRollbackFunction Pointer to a function of type RFC_ON_ROLLBACK_UNIT.
/// \in onConfirmFunction Pointer to a function of type RFC_ON_CONFIRM_UNIT.
/// \in onGetStateFunction Pointer to a function of type RFC_ON_GET_UNIT_STATE.
/// \out *errorInfo Additional information, in case the handlers could not be installed.
/// \return RFC_RC
    pub fn RfcInstallBgRfcHandlers(sysId: *const SAP_UC,
                                   onCheckFunction: RFC_ON_CHECK_UNIT,
                                   onCommitFunction: RFC_ON_COMMIT_UNIT,
                                   onRollbackFunction: RFC_ON_ROLLBACK_UNIT,
                                   onConfirmFunction: RFC_ON_CONFIRM_UNIT,
                                   onGetStateFunction: RFC_ON_GET_UNIT_STATE,
                                   errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Installs the necessary callback functions for processing Extended Passport (EPP) events.
/// \ingroup installer
///
/// Extended Passports is a feature that supersedes Distributed Statistical Records (DSRs).
/// It allows to track certain performance attributes across system boundaries. These callback functions
/// allow the application to exchange passports with the backend system. The actual data contained in the
/// passports, can be processed with the eppslib library.
/// \note Normal RFC applications should never need to deal with this topic at all...
///
///
/// \in onClientCallStart Pointer to a function of type RFC_PM_CALLBACK. The RFC lib calls this function, before it sends a client request into the backend. Here you can provide the passport that is to be sent along with the RFC request.
/// \in onClientCallEnd Pointer to a function of type RFC_PM_CALLBACK. The RFC lib calls this function, after the RFC response was received from the backend. You can read the updated passport information.
/// \in onServerCallStart Pointer to a function of type RFC_PM_CALLBACK. The RFC lib calls this function, when it received an RFC request from the backend. Here you can read the passport that accompanied the request.
/// \in onServerCallEnd Pointer to a function of type RFC_PM_CALLBACK. The RFC lib calls this function, before it will send the response to the above request back to the backend. You can update the passport data with information about processing performance of the current call.
/// \out *errorInfo Additional information, in case the handlers could not be installed.
/// \return RFC_RC
    pub fn RfcInstallPassportManager(onClientCallStart: RFC_PM_CALLBACK,
                                     onClientCallEnd: RFC_PM_CALLBACK,
                                     onServerCallStart: RFC_PM_CALLBACK,
                                     onServerCallEnd: RFC_PM_CALLBACK,
                                     errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Installs an optional callback function for processing password change events.
/// \ingroup installer
///
/// Whenever a logon attempt is made with a user, whose password is still initial, the backend system
/// challenges this user to change his/her password. If this happens during a call to RfcOpenConnection(),
/// the RFC library calls this callback function (if installed), and allows you to change the user's password.
/// In your implementation, you can either return RFC_EXTERNAL_FAILURE, if you can't/don't want to change
/// the password. In that case RfcOpenConnection() will end with RFC_LOGON_FAILURE and any additional text from
/// errorInfo->message will be returned to the application. Or you can fill the old and new password with correct
/// values and return RFC_OK, upon which the RFC library will attempt to change the password accordingly.
///
///
/// \in onPasswordChange Pointer to a function of type RFC_ON_PASSWORD_CHANGE. The RFC lib calls this function, whenever an initial password is detected during a call to RfcOpenConnection().
/// \out *errorInfo Additional information, in case the handler could not be installed.
/// \return RFC_RC
    pub fn RfcInstallPasswordChangeHandler(onPasswordChange:
                                               RFC_ON_PASSWORD_CHANGE,
                                           errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Installs an optional callback function for performing authorization checks on incoming function calls.
/// \ingroup installer
///
/// After an RFC call arrives at the RFC library, and before the library executes the corresponding
/// server implementation for that function module, it calls this callback function, if installed.
/// Here you can implement a central authorization check, defining exactly which user from which backend
/// system is allowed to execute what functions in your RFC server program.
/// The actual function module implementations can then concentrate on their business logic and don't
/// need to pay attention to access and authorization checks.
///
///
/// \in onAuthorizationCheck Pointer to a function of type RFC_ON_AUTHORIZATION_CHECK. The RFC lib calls this function, whenever an RFC request arrives from the backend.
/// \out *errorInfo Additional information, in case the handler could not be installed.
/// \return RFC_RC
    pub fn RfcInstallAuthorizationCheckHandler(onAuthorizationCheck:
                                                   RFC_ON_AUTHORIZATION_CHECK,
                                               errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Creates a data container that can be used to execute function calls in the backend via RfcInvoke().
/// \ingroup container
///
/// The importing parameters can be set using the RfcSetX functions. After the RfcInvoke() call returned
/// successfully, the exporting parameters can be read from this data container via the RfcGetX functions.
///
///
/// \in funcDescHandle Metadata description ("blueprint") for the data container to be created.
/// \out *errorInfo Error information in case the parameters are incorrect or there's not enough memory.
/// \return A handle to the function module container.
    pub fn RfcCreateFunction(funcDescHandle: RFC_FUNCTION_DESC_HANDLE,
                             errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_FUNCTION_HANDLE;
}
extern "C" {
    /// \brief  Releases all memory used by the data container.
/// \ingroup container
///
/// \warning Be careful: if you have obtained a handle to a structure (RFC_STRUCTURE_HANDLE) or
/// table parameter (RFC_TABLE_HANDLE) from that function module, that handle will be invalid afterwards,
/// as that memory will be released as well!
///
///
/// \in funcHandle Data container to release.
/// \out *errorInfo Not much that can go wrong here.
/// \return RFC_RC
    pub fn RfcDestroyFunction(funcHandle: RFC_FUNCTION_HANDLE,
                              errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Allows to deactivate certain parameters in the function module interface.
/// \ingroup container
///
/// This is particularly useful for BAPIs which have many large tables, in which you are not interested.
/// Deactivate those and leave only those tables active, in which you are interested. This reduces
/// network traffic and memory consumption in your application considerably.
///
/// \note This functionality can be used for input and output parameters. If the parameter is an input,
/// no data for that parameter will be sent to the backend. If it's an output, the backend will be
/// informed not to return data for that parameter.
///
/// \in funcHandle A function module data container.
/// \in *paramName The name of a parameter of this function module.
/// \in isActive 1 = activate, 0 = deactivate.
/// \out *errorInfo Error information in case something goes wrong (e.g. a parameter of that name does not exist).
/// \return RFC_RC
    pub fn RfcSetParameterActive(funcHandle: RFC_FUNCTION_HANDLE,
                                 paramName: *const SAP_UC,
                                 isActive: ::std::os::raw::c_int,
                                 errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Query whether a parameter is active.
/// \ingroup container
///
/// Useful for example in a server function implementation: Before creating a large table,
/// you may want to check, whether the client (the backend system), has requested that table at all.
///
/// \in funcHandle A function module data container (usually handed to your server function from the RFC library).
/// \in *paramName The name of a parameter of this function module.
/// \out *isActive 1 = is active, 0 = is not active.
/// \out *errorInfo Error information in case something goes wrong (e.g. a parameter of that name does not exist).
/// \return RFC_RC
    pub fn RfcIsParameterActive(funcHandle: RFC_FUNCTION_HANDLE,
                                paramName: *const SAP_UC,
                                isActive: *mut ::std::os::raw::c_int,
                                errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Creates a data container for a structure.
/// \ingroup container
///
///
/// \in typeDescHandle The metadata description (blueprint) for the structure to be created.
/// \out *errorInfo Error information in case the parameters are incorrect or there's not enough memory.
/// \return A handle to the structure.
    pub fn RfcCreateStructure(typeDescHandle: RFC_TYPE_DESC_HANDLE,
                              errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_STRUCTURE_HANDLE;
}
extern "C" {
    /// \brief  Clones a sructure including the data in it.
/// \ingroup container
///
///
/// \in srcStructureHandle The structure to clone.
/// \out *errorInfo Not enough memory?
/// \return A handle to the newly created copy of the input structure.
    pub fn RfcCloneStructure(srcStructureHandle: RFC_STRUCTURE_HANDLE,
                             errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_STRUCTURE_HANDLE;
}
extern "C" {
    /// \brief  Releases all memory for a particular structure
/// \ingroup container
///
/// \warning Do not call this function on structures, which you have obtained from another data container
/// (e.g. a function module) via RfcGetStructure(). In that case the memory will be released, when the
/// parent container will be destroyed. If you destroy a child structure separately, you will get a
/// segmentation fault, when the parent structure is destroyed!
///
/// \in structHandle Structure to release.
/// \out *errorInfo Not much that can go wrong here.
/// \return RFC_RC
    pub fn RfcDestroyStructure(structHandle: RFC_STRUCTURE_HANDLE,
                               errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Creates a data container for a table.
/// \ingroup container
///
///
/// \in typeDescHandle The metadata description (blueprint) for the line type of the table to be created.
/// \out *errorInfo More details in case there was an invalid parameter or not enough memory.
/// \return The freshly created table.
    pub fn RfcCreateTable(typeDescHandle: RFC_TYPE_DESC_HANDLE,
                          errorInfo: *mut RFC_ERROR_INFO) -> RFC_TABLE_HANDLE;
}
extern "C" {
    /// \brief  Clones a table including all the data in it. (Use with care...)
/// \ingroup container
///
///
/// \in srcTableHandle The table to duplicate.
/// \out *errorInfo In case there is not enough memory.
/// \return A handle to the cloned table.
    pub fn RfcCloneTable(srcTableHandle: RFC_TABLE_HANDLE,
                         errorInfo: *mut RFC_ERROR_INFO) -> RFC_TABLE_HANDLE;
}
extern "C" {
    /// \brief  Releases the memory of a table and all its lines.
/// \ingroup container
///
/// \warning Be careful: if you still have a reference to a certain table line (an RFC_STRUCTURE_HANDLE you got
/// from RfcGetCurrentRow() / RfcAppendNewRow() / RfcInsertNewRow()), this handle will be invalid after %RfcDestroyTable()!
/// Using a handle to a table line after the table has been destroyed, will lead to a segmentation fault.
///
/// \in tableHandle The table to release.
/// \out *errorInfo Nothing can go wrong here...
/// \return RFC_RC
    pub fn RfcDestroyTable(tableHandle: RFC_TABLE_HANDLE,
                           errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the table row, on which the "table cursor" is currently positioned.
/// \ingroup container
///
/// \note that the rows are numbered from 0 to n-1, not from 1 to n, as it's done in ABAP.
///
/// \in tableHandle The table to read data from.
/// \out *errorInfo If the table cursor is not on a valid position.
/// \return A handle to the current row.
/// \warning Do not destroy the returned RFC_STRUCTURE_HANDLE.
    pub fn RfcGetCurrentRow(tableHandle: RFC_TABLE_HANDLE,
                            errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_STRUCTURE_HANDLE;
}
extern "C" {
    /// \brief  Appends a new empty row at the end of the table and moves the table cursor to that row.
/// \ingroup container
///
///
/// \in tableHandle The table to enlarge.
/// \out *errorInfo More information in case of errors (e.g. not enough memory).
/// \return A handle to the newly created row.
    pub fn RfcAppendNewRow(tableHandle: RFC_TABLE_HANDLE,
                           errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_STRUCTURE_HANDLE;
}
extern "C" {
    /// \brief  Appends a set of new empty rows at the end of the table and moves the table cursor to the first new row.
/// \ingroup container
///
///
/// \in tableHandle The table to enlarge.
/// \in numRows Number of rows to add.
/// \out *errorInfo More information in case of errors (e.g. not enough memory).
/// \return RFC_OK, RFC_INVALID_HANDLE or RFC_MEMORY_INSUFFICIENT.
    pub fn RfcAppendNewRows(tableHandle: RFC_TABLE_HANDLE,
                            numRows: ::std::os::raw::c_uint,
                            errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Inserts a new empty row at the current position of the table cursor.
/// \ingroup container
///
/// The row, on which the table cursor is currently positioned, and all following rows are moved
/// one index "down". E.g. if the table currently has rows nos 0 - n-1 and the cursor points to row i,
/// then the rows i - n-1 are moved to positions i+1 - n, and the new row is inserted at position i.
///
///
/// \in tableHandle The table to enlarge.
/// \out *errorInfo More information in case of errors (e.g. not enough memory).
/// \return A handle to the newly created row.
    pub fn RfcInsertNewRow(tableHandle: RFC_TABLE_HANDLE,
                           errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_STRUCTURE_HANDLE;
}
extern "C" {
    /// \brief  Appends an existing row to the end of the table and moves the table cursor to that row.
/// \ingroup container
///
///
/// \in tableHandle The table to enlarge.
/// \in structHandle The row to append to the table.
/// \out *errorInfo More information in case something goes wrong (e.g. the line types of the table and the structure don't match).
/// \return RFC_RC
    pub fn RfcAppendRow(tableHandle: RFC_TABLE_HANDLE,
                        structHandle: RFC_STRUCTURE_HANDLE,
                        errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Inserts an existing row at the current position of the table cursor.
/// \ingroup container
///
/// The row, on which the table cursor is currently positioned, and all following rows are moved
/// one index "down". E.g. if the table currently has rows nos 0 - n-1 and the cursor points to row i,
/// then the rows i - n-1 are moved to positions i+1 - n, and the given row is inserted at position i.
///
///
/// \in tableHandle The table to enlarge.
/// \in structHandle The row to insert into the table.
/// \out *errorInfo More information in case something goes wrong (e.g. the line types of the table and the structure don't match).
/// \return RFC_RC
    pub fn RfcInsertRow(tableHandle: RFC_TABLE_HANDLE,
                        structHandle: RFC_STRUCTURE_HANDLE,
                        errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Deletes the row, on which the table cursor is currently positioned.
/// \ingroup container
///
/// If the row cursor is currently at an index i between 0 - n-2, then row i will be deleted and the
/// rows i+1 - n-1 will be moved on index "up", e.g. will now be rows i - n-2. The table cursor will
/// remain fixed at index i.\n
/// If the cursor is currently on the last row (n-1), then that row will be deleted, all other position
/// will remain unchanged, and the table cursor will move up to n-2 (the new last row of the table).
///
///
/// \in tableHandle The table from which to delete a row.
/// \out *errorInfo Error information in case the table cursor is not on a valid position.
/// \return RFC_RC
    pub fn RfcDeleteCurrentRow(tableHandle: RFC_TABLE_HANDLE,
                               errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Deletes all rows from the table.
/// \ingroup container
///
///
/// \in tableHandle The table to clear.
/// \out *errorInfo Not much that can go wrong here (except an invalid table handle).
/// \return RFC_RC
    pub fn RfcDeleteAllRows(tableHandle: RFC_TABLE_HANDLE,
                            errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Positions the table cursor at the first row (or at index "-1", if the table is empty).
/// \ingroup container
///
///
/// \in tableHandle A table.
/// \out *errorInfo Not much that can go wrong here (except an invalid table handle).
/// \return RFC_RC
    pub fn RfcMoveToFirstRow(tableHandle: RFC_TABLE_HANDLE,
                             errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Positions the table cursor at the last row (or at index "-1", if the table is empty).
/// \ingroup container
///
///
/// \in tableHandle A table.
/// \out *errorInfo Not much that can go wrong here (except an invalid table handle).
/// \return RFC_RC
    pub fn RfcMoveToLastRow(tableHandle: RFC_TABLE_HANDLE,
                            errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Increments the table cursor by one.
/// \ingroup container
///
///
/// \in tableHandle A table.
/// \out *errorInfo Not much that can go wrong here (except an invalid table handle).
/// \return RFC_RC
    pub fn RfcMoveToNextRow(tableHandle: RFC_TABLE_HANDLE,
                            errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Decrements the table cursor by one.
/// \ingroup container
///
///
/// \in tableHandle A table.
/// \out *errorInfo Not much that can go wrong here (except an invalid table handle).
/// \return RFC_RC
    pub fn RfcMoveToPreviousRow(tableHandle: RFC_TABLE_HANDLE,
                                errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the table cursor to a specific index.
/// \ingroup container
///
///
/// \in tableHandle A table.
/// \in index The index to which to move the cursor.
/// \out *errorInfo Index out of bounds or invalid table handle.
/// \return RFC_RC
    pub fn RfcMoveTo(tableHandle: RFC_TABLE_HANDLE,
                     index: ::std::os::raw::c_uint,
                     errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the number of rows in a table.
/// \ingroup container
///
///
/// \in tableHandle A table.
/// \out *rowCount The number of rows in the table.
/// \out *errorInfo Not much that can go wrong.
/// \return RFC_RC
    pub fn RfcGetRowCount(tableHandle: RFC_TABLE_HANDLE,
                          rowCount: *mut ::std::os::raw::c_uint,
                          errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns a type description handle describing the line type (metadata) of this table.
/// \ingroup container
///
///
/// \in tableHandle A table.
/// \out *errorInfo Not much that can go wrong.
/// \return A type description handle that provides information about this table's fields (for each field: fieldname, the field's datatype, length, offset, etc.)
    pub fn RfcGetRowType(tableHandle: RFC_TABLE_HANDLE,
                         errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_TYPE_DESC_HANDLE;
}
extern "C" {
    /// \brief  Creates an ABAP object handle with the given class description handle.
/// \ingroup container
///
/// \in classDescHandle   class description handle.
/// \out *errorInfo  Contains more information, for example if memory runs out (code = RFC_MEMORY_INSUFFICIENT).
/// \return A handle to the created ABAP object.
    pub fn RfcCreateAbapObject(classDescHandle: RFC_CLASS_DESC_HANDLE,
                               errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_ABAP_OBJECT_HANDLE;
}
extern "C" {
    /// \brief  Destroys an ABAP object handle.
/// \ingroup container
///
/// \in objHandle    ABAP object handle to be destroyed.
/// \out *errorInfo  Should always return successfully.
/// \return RFC_RC
    pub fn RfcDestroyAbapObject(objHandle: RFC_ABAP_OBJECT_HANDLE,
                                errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the value of the specified field as char array.
/// \ingroup container
///
/// The charBuffer will be filled with a string representation of the given field. The remaining
/// places in the buffer will be filled with trailing spaces. In case the buffer is too small,
/// the function will return RFC_BUFFER_TOO_SMALL. The result will not be null-terminated.
///
/// The field specified by name needs to be of one of the following data types. If the field
/// has one of the listed non-char-like data types, the RFC library will convert the field value
/// to string format. Example:\n
/// If "name" specifies a field of type INT4 with the value 4711 and charBuffer is an SAP_CHAR[10],
/// then the buffer will be filled as follows: "4711      ".
///
/// \note If the target field has type BYTE or XSTRING, the bytes will be
/// converted to a hex encoded string representation.
///
/// - RFCTYPE_CHAR
/// - RFCTYPE_STRING
/// - RFCTYPE_NUM
/// - RFCTYPE_DATE
/// - RFCTYPE_TIME
/// - RFCTYPE_INTx
/// - RFCTYPE_FLOAT
/// - RFCTYPE_BCD
/// - RFCTYPE_DECFxx
/// - RFCTYPE_BYTE
/// - RFCTYPE_XSTRING
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in *name The name of the field.
/// \out *charBuffer A pre-allocated buffer, which will receive the (converted) field value.
/// \in bufferLength Size of the buffer in RFC_CHARs.
/// \out *errorInfo Field doesn't exist, cannot be converted to char, etc.
/// \return RFC_RC
    pub fn RfcGetChars(dataHandle: DATA_CONTAINER_HANDLE, name: *const SAP_UC,
                       charBuffer: *mut RFC_CHAR,
                       bufferLength: ::std::os::raw::c_uint,
                       errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the value of the specified field as char array.
/// \ingroup container
///
/// This function works exactly like RfcGetChars(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in index The index of the field.
/// \out *charBuffer A pre-allocated buffer, which will receive the (converted) field value.
/// \in bufferLength Size of the buffer in RFC_CHARs.
/// \out *errorInfo Field doesn't exist, cannot be converted to char, etc.
/// \return RFC_RC
    pub fn RfcGetCharsByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                              index: ::std::os::raw::c_uint,
                              charBuffer: *mut RFC_CHAR,
                              bufferLength: ::std::os::raw::c_uint,
                              errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the value of the specified field as num-char array (digits only).
/// \ingroup container
///
/// The charBuffer will be filled with a string representation of the field (from right to left).
/// The remaining places in the buffer will be filled with leading zero digits. In case
/// the buffer is too small, the function will return RFC_BUFFER_TOO_SMALL. The result is not
/// null-terminated.
///
/// The field specified by name needs to be of one of the following data types. If the field
/// has one of the listed non-char-like data types, the RFC library will convert the field value
/// to string format. Example:\n
/// If "name" specifies a field of type INT4 with the value 4711 and charBuffer is an SAP_CHAR[10],
/// then the buffer will be filled as follows: "0000004711".
///
/// - RFCTYPE_CHAR
/// - RFCTYPE_STRING
/// - RFCTYPE_NUM
/// - RFCTYPE_DATE
/// - RFCTYPE_TIME
/// - RFCTYPE_INTx
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in *name The name of the field.
/// \out *charBuffer A pre-allocated buffer, which will receive the (converted) field value.
/// \in bufferLength Size of the buffer in RFC_CHARs.
/// \out *errorInfo Field doesn't exist, cannot be converted to numc, etc.
/// \return RFC_RC
    pub fn RfcGetNum(dataHandle: DATA_CONTAINER_HANDLE, name: *const SAP_UC,
                     charBuffer: *mut RFC_NUM,
                     bufferLength: ::std::os::raw::c_uint,
                     errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the value of the specified field as num-char array (digits only).
/// \ingroup container
///
/// This function works exactly like RfcGetNum(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in index The index of the field.
/// \out *charBuffer A pre-allocated buffer, which will receive the (converted) field value.
/// \in bufferLength Size of the buffer in RFC_CHARs.
/// \out *errorInfo Field doesn't exist, cannot be converted to numc, etc.
/// \return RFC_RC
    pub fn RfcGetNumByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                            index: ::std::os::raw::c_uint,
                            charBuffer: *mut RFC_NUM,
                            bufferLength: ::std::os::raw::c_uint,
                            errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Reads a DATE field.
/// \ingroup container
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in *name The name of the field to read. The field must be of type RFCTYPE_DATE.
/// \out emptyDate An RFC_DATE object, which will receive the field value.
/// \out *errorInfo More information in case something goes wrong.
/// \return RFC_RC
    pub fn RfcGetDate(dataHandle: DATA_CONTAINER_HANDLE, name: *const SAP_UC,
                      emptyDate: *mut RFC_CHAR,
                      errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Reads a DATE field.
/// \ingroup container
///
/// This function works exactly like RfcGetDate(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in index The index of the field to read. The field must be of type RFCTYPE_DATE.
/// \out emptyDate An RFC_DATE object, which will receive the field value.
/// \out *errorInfo More information in case something goes wrong.
/// \return RFC_RC
    pub fn RfcGetDateByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                             index: ::std::os::raw::c_uint,
                             emptyDate: *mut RFC_CHAR,
                             errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Reads a TIME field.
/// \ingroup container
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in *name The name of the field to read. The field must be of type RFCTYPE_TIME.
/// \out emptyTime An RFC_TIME object, which will receive the field value.
/// \out *errorInfo More information in case something goes wrong.
/// \return RFC_RC
    pub fn RfcGetTime(dataHandle: DATA_CONTAINER_HANDLE, name: *const SAP_UC,
                      emptyTime: *mut RFC_CHAR,
                      errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Reads a TIME field.
/// \ingroup container
///
/// This function works exactly like RfcGetTime(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in index The index of the field to read. The field must be of type RFCTYPE_TIME.
/// \out emptyTime An RFC_TIME object, which will receive the field value.
/// \out *errorInfo More information in case something goes wrong.
/// \return RFC_RC
    pub fn RfcGetTimeByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                             index: ::std::os::raw::c_uint,
                             emptyTime: *mut RFC_CHAR,
                             errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the value of the specified field as null-terminated string.
/// \ingroup container
///
/// The charBuffer will be filled with a null-terminated string representation of the field value.
/// In case the buffer is too small, e.g. no place for string termination, the function will
/// return RFC_BUFFER_TOO_SMALL. stringLength contains the number of written characters, or the
/// required number of characters in case RFC_BUFFER_TOO_SMALL was thrown.
/// The result will be null-terminated.
///
/// The field specified by name needs to be of one of the following data types. If the field
/// has one of the listed non-char-like data types, the RFC library will convert the field value
/// to string format. Example:\n
/// If "name" specifies a field of type INT4 with the value 4711 and stringBuffer is an SAP_UC[10],
/// then the buffer will be filled as follows: "4711\0xxxxx". (x: left unchanged.)
///
/// \note If the target field has type BYTE or XSTRING, the bytes will be
/// converted to a hex encoded string representation.
///
/// - RFCTYPE_CHAR
/// - RFCTYPE_STRING
/// - RFCTYPE_NUM
/// - RFCTYPE_DATE
/// - RFCTYPE_TIME
/// - RFCTYPE_INTx
/// - RFCTYPE_FLOAT
/// - RFCTYPE_BCD
/// - RFCTYPE_DECFxx
/// - RFCTYPE_BYTE
/// - RFCTYPE_XSTRING
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in *name The name of the field to read.
/// \out *stringBuffer Pre-allocated buffer, which will receive the (converted) field value.
/// \in bufferLength Size of the buffer in SAP_UC.
/// \out *stringLength Always returns the string's length, no matter whether the stringBuffer had
/// been large enough or not. (Note that if you want to try again after an RFC_BUFFER_TOO_SMALL,
/// you need to make the stringBuffer at least *stringLength + 1 in order to account for the terminating null.)
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcGetString(dataHandle: DATA_CONTAINER_HANDLE,
                        name: *const SAP_UC, stringBuffer: *mut SAP_UC,
                        bufferLength: ::std::os::raw::c_uint,
                        stringLength: *mut ::std::os::raw::c_uint,
                        errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the value of the specified field as null-terminated string.
/// \ingroup container
///
/// This function works exactly like RfcGetString(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in index The index of the field to read.
/// \out *stringBuffer Pre-allocated buffer, which will receive the (converted) field value.
/// \in bufferLength Size of the buffer in SAP_UC.
/// \out *stringLength Always returns the string's length, no matter whether the stringBuffer had
/// been large enough or not. (Note that if you want to try again after an RFC_BUFFER_TOO_SMALL,
/// you need to make the stringBuffer at least *stringLength + 1 in order to account for the termnating null.)
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcGetStringByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                               index: ::std::os::raw::c_uint,
                               stringBuffer: *mut SAP_UC,
                               bufferLength: ::std::os::raw::c_uint,
                               stringLength: *mut ::std::os::raw::c_uint,
                               errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the value of the specified field as byte array.
/// \ingroup container
///
/// Should mainly be used with fields of type RAW (RFCTYPE_BYTE), but also works with
/// a number of other data types. In case of numerical data types it simply gives the
/// binary representation of the value, in case of character data types it gives the
/// UTF-16 representation (little endian/big endian, depending on the host platform).
/// In case the buffer is too small, the function will return RFC_BUFFER_TOO_SMALL.
/// In case the buffer is longer than the field, it will be filled with 0x00 values.
/// Example: The field is of type INT4 and contains the value 4711, byteBuffer is an SAP_RAW[10].
/// Then the buffer will be filled as follows: 67 12 00 00 00 00 00 00 00 00 (little endian system)
/// or 00 00 12 67 00 00 00 00 00 00 (big endian system).
///
/// The field specified by name needs to be of one of the following data types:
/// - RFCTYPE_BYTE
/// - RFCTYPE_XSTRING
/// - RFCTYPE_CHAR
/// - RFCTYPE_NUM
/// - RFCTYPE_DATE
/// - RFCTYPE_TIME
/// - RFCTYPE_INTx
/// - RFCTYPE_FLOAT
/// - RFCTYPE_BCD
/// - RFCTYPE_DECFxx
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in *name The name of the field to read.
/// \out *byteBuffer Pre-allocated buffer, which will receive the (converted) field value.
/// \in bufferLength Size of the buffer in bytes.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcGetBytes(dataHandle: DATA_CONTAINER_HANDLE, name: *const SAP_UC,
                       byteBuffer: *mut SAP_RAW,
                       bufferLength: ::std::os::raw::c_uint,
                       errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the value of the specified field as byte array.
/// \ingroup container
///
/// This function works exactly like RfcGetBytes(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in index The index of the field to read.
/// \out *byteBuffer Pre-allocated buffer, which will receive the (converted) field value.
/// \in bufferLength Size of the buffer in bytes.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcGetBytesByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                              index: ::std::os::raw::c_uint,
                              byteBuffer: *mut SAP_RAW,
                              bufferLength: ::std::os::raw::c_uint,
                              errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the value of the specified field as byte array.
/// \ingroup container
///
/// In case the buffer is too small, the function will return RFC_BUFFER_TOO_SMALL.
/// xstringLength contains the number of written bytes, or the required number of bytes
/// in case of RFC_BUFFER_TOO_SMALL.
/// The remaining buffer won't be changed.
///
/// Example: The field is of type INT4 and contains the value 4711, byteBuffer is an SAP_RAW[10].
/// Then the buffer will be filled as follows: 67 12 00 00 x x x x x x (little endian system)
/// or 00 00 12 67 x x x x x x (big endian system). (x: unchanged) In both cases *xstringLength
/// will be 4.
///
/// The field specified by name needs to be of one of the following data types:
/// - RFCTYPE_BYTE
/// - RFCTYPE_XSTRING
/// - RFCTYPE_CHAR
/// - RFCTYPE_NUM
/// - RFCTYPE_DATE
/// - RFCTYPE_TIME
/// - RFCTYPE_INTx
/// - RFCTYPE_FLOAT
/// - RFCTYPE_BCD
/// - RFCTYPE_DECFxx
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in *name The name of the field to read.
/// \out *byteBuffer Pre-allocated buffer, which will receive the (converted) field value.
/// \in bufferLength Size of the buffer in bytes.
/// \out *xstringLength Byte length of the result (in both cases, no matter whether the byteBuffer had
/// been large enough or not).
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcGetXString(dataHandle: DATA_CONTAINER_HANDLE,
                         name: *const SAP_UC, byteBuffer: *mut SAP_RAW,
                         bufferLength: ::std::os::raw::c_uint,
                         xstringLength: *mut ::std::os::raw::c_uint,
                         errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the value of the specified field as byte array.
/// \ingroup container
///
/// This function works exactly like RfcGetXString(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in index The index of the field to read.
/// \out *byteBuffer Pre-allocated buffer, which will receive the (converted) field value.
/// \in bufferLength Size of the buffer in bytes.
/// \out *xstringLength Byte length of the result (in both cases, no matter whether the byteBuffer had
/// been large enough or not).
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcGetXStringByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                                index: ::std::os::raw::c_uint,
                                byteBuffer: *mut SAP_RAW,
                                bufferLength: ::std::os::raw::c_uint,
                                xstringLength: *mut ::std::os::raw::c_uint,
                                errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the value of the specified field as RFC_INT (signed).
/// \ingroup container
///
/// If the field is a character type, an "atoi-like" conversion is performed. If the field is of type
/// RFCTYPE_BYTE/RFCTYPE_XSTRING, this function interprets the bytes in big-endian byte order when
/// converting them to int. Note that in this case the byte length of the field value must not exceed 4!
///
/// The field specified by name needs to be of one of the following data types:
/// - RFCTYPE_INT
/// - RFCTYPE_INT2
/// - RFCTYPE_INT1
/// - RFCTYPE_BYTE     is interpreted as big endian sequence of an int
/// - RFCTYPE_XSTRING  is interpreted as big endian sequence of an int
/// - RFCTYPE_CHAR
/// - RFCTYPE_NUM
/// - RFCTYPE_STRING
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in *name The name of the field to read.
/// \out *value The (converted) integer value.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcGetInt(dataHandle: DATA_CONTAINER_HANDLE, name: *const SAP_UC,
                     value: *mut RFC_INT, errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the value of the specified field as RFC_INT (signed).
/// \ingroup container
///
/// This function works exactly like RfcGetInt(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in index The index of the field to read.
/// \out *value The (converted) integer value.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcGetIntByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                            index: ::std::os::raw::c_uint,
                            value: *mut RFC_INT,
                            errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the value of a field as an unsigned one byte integer.
/// \ingroup container
///
/// The current field value must not be bigger than 255, otherwise you'll get an RFC_CONVERSION_ERROR.
/// If the field is of type RFCTYPE_BYTE/RFCTYPE_XSTRING, the field length must be 1 byte.
///
/// The field specified by name needs to be of one of the following data types:
/// - RFCTYPE_INT
/// - RFCTYPE_INT2
/// - RFCTYPE_INT1
/// - RFCTYPE_BYTE
/// - RFCTYPE_XSTRING
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in *name The name of the field to read.
/// \out *value The (converted) integer value.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcGetInt1(dataHandle: DATA_CONTAINER_HANDLE, name: *const SAP_UC,
                      value: *mut RFC_INT1, errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the value of a field as an unsigned one byte integer.
/// \ingroup container
///
/// This function works exactly like RfcGetInt1(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in index The index of the field to read.
/// \out *value The (converted) integer value.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcGetInt1ByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                             index: ::std::os::raw::c_uint,
                             value: *mut RFC_INT1,
                             errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the field value as a signed two byte integer.
/// \ingroup container
///
/// The current field value must be between -32768 and 32767, otherwise you'll get an RFC_CONVERSION_ERROR.
/// If the field is of type RFCTYPE_BYTE/RFCTYPE_XSTRING, the field length must be 1 or 2 bytes.
///
/// The field specified by name needs to be of one of the following data types:
/// - RFCTYPE_INT
/// - RFCTYPE_INT2
/// - RFCTYPE_INT1
/// - RFCTYPE_BYTE     is interpreted as big endian sequence of a short
/// - RFCTYPE_XSTRING  is interpreted as big endian sequence of a short
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in *name The name of the field to read.
/// \out *value The (converted) integer value.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcGetInt2(dataHandle: DATA_CONTAINER_HANDLE, name: *const SAP_UC,
                      value: *mut RFC_INT2, errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the field value as a signed two byte integer.
/// \ingroup container
///
/// This function works exactly like RfcGetInt2(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in index The index of the field to read.
/// \out *value The (converted) integer value.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcGetInt2ByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                             index: ::std::os::raw::c_uint,
                             value: *mut RFC_INT2,
                             errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the value of the given field as an RFC_FLOAT.
/// \ingroup container
///
/// The field specified by name needs to be of one of the following data types:
/// - RFCTYPE_FLOAT
/// - RFCTYPE_BCD
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in *name The name of the field to read.
/// \out *value The floating point value.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcGetFloat(dataHandle: DATA_CONTAINER_HANDLE, name: *const SAP_UC,
                       value: *mut RFC_FLOAT, errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the value of the given field as an RFC_FLOAT.
/// \ingroup container
///
/// This function works exactly like RfcGetFloat(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in index The index of the field to read.
/// \out *value The floating point value.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcGetFloatByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                              index: ::std::os::raw::c_uint,
                              value: *mut RFC_FLOAT,
                              errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the field as an 8 byte IEEE 754r decimal floating point.
/// \ingroup container
///
/// See the header sapdecf.h for how to work with RFC_DECF16 objects. If the field has a binary
/// data type, its field length needs to be 8 bytes.
///
/// The field specified by name needs to be of one of the following data types:
/// - RFCTYPE_DECF16
/// - RFCTYPE_DECF34
/// - RFCTYPE_FLOAT
/// - RFCTYPE_BCD
/// - RFCTYPE_INT
/// - RFCTYPE_INT2
/// - RFCTYPE_INT1
/// - RFCTYPE_CHAR
/// - RFCTYPE_NUM
/// - RFCTYPE_STRING
/// - RFCTYPE_BYTE     is interpreted as IEEE 754r format
/// - RFCTYPE_XSTRING  is interpreted as IEEE 754r format
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in *name The name of the field to read.
/// \out *value The (converted) decimal floating point value.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcGetDecF16(dataHandle: DATA_CONTAINER_HANDLE,
                        name: *const SAP_UC, value: *mut RFC_DECF16,
                        errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the field as an 8 byte IEEE 754r decimal floating point.
/// \ingroup container
///
/// This function works exactly like RfcGetDecF16(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in index The index of the field to read.
/// \out *value The (converted) decimal floating point value.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcGetDecF16ByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                               index: ::std::os::raw::c_uint,
                               value: *mut RFC_DECF16,
                               errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the field as a 16 byte IEEE 754r decimal floating point.
/// \ingroup container
///
/// See the header sapdecf.h for how to work with RFC_DECF16 objects. If the field has a binary
/// data type, its field length needs to be 16 bytes.
///
/// The field specified by name needs to be of one of the following data types:
/// - RFCTYPE_DECF16
/// - RFCTYPE_DECF34
/// - RFCTYPE_FLOAT
/// - RFCTYPE_BCD
/// - RFCTYPE_INT
/// - RFCTYPE_INT2
/// - RFCTYPE_INT1
/// - RFCTYPE_CHAR
/// - RFCTYPE_NUM
/// - RFCTYPE_STRING
/// - RFCTYPE_BYTE     is interpreted as IEEE 754r format
/// - RFCTYPE_XSTRING  is interpreted as IEEE 754r format
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in *name The name of the field to read.
/// \out *value The (converted) decimal floating point value.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcGetDecF34(dataHandle: DATA_CONTAINER_HANDLE,
                        name: *const SAP_UC, value: *mut RFC_DECF34,
                        errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the field as a 16 byte IEEE 754r decimal floating point.
/// \ingroup container
///
/// This function works exactly like RfcGetDecF34(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in index The index of the field to read.
/// \out *value The (converted) decimal floating point value.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcGetDecF34ByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                               index: ::std::os::raw::c_uint,
                               value: *mut RFC_DECF34,
                               errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns a handle to a structure.
/// \ingroup container
///
/// The field specified by name must be of type RFCTYPE_STRUCTURE. If that field has not yet
/// been accessed/filled previously, a new empty structure is created from the metadata of the
/// parent data container ("dataHandle") and returned.
/// \warning The memory of that data container will be released, when the parent container gets
/// destroyed. So don't destroy the returned structure handle, nor continue to use it, after the
/// parent has been destroyed!
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in *name The name of the field to read.
/// \out *structHandle A handle to the sub-structure.
/// \out *errorInfo Field does not exist, is of wrong type or out of memory.
/// \return RFC_RC
    pub fn RfcGetStructure(dataHandle: DATA_CONTAINER_HANDLE,
                           name: *const SAP_UC,
                           structHandle: *mut RFC_STRUCTURE_HANDLE,
                           errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns a handle to a structure.
/// \ingroup container
///
/// This function works exactly like RfcGetStructure(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in index The index of the field to read.
/// \out *structHandle A handle to the sub-structure.
/// \out *errorInfo Field does not exist, is of wrong type or out of memory.
/// \return RFC_RC
    pub fn RfcGetStructureByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                                  index: ::std::os::raw::c_uint,
                                  structHandle: *mut RFC_STRUCTURE_HANDLE,
                                  errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns a handle to a table.
/// \ingroup container
///
/// The field specified by name must be of type RFCTYPE_TABLE. If that field has not yet
/// been accessed/filled previously, a new empty structure is created from the metadata of the
/// parent data container ("dataHandle") and returned.
/// \warning The memory of that data container will be released, when the parent container gets
/// destroyed. So don't destroy the returned table handle, nor continue to use it, after the
/// parent has been destroyed!
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in *name The name of the field to read.
/// \out *tableHandle A handle to the sub-table.
/// \out *errorInfo Field does not exist, is of wrong type or out of memory.
/// \return RFC_RC
    pub fn RfcGetTable(dataHandle: DATA_CONTAINER_HANDLE, name: *const SAP_UC,
                       tableHandle: *mut RFC_TABLE_HANDLE,
                       errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns a handle to a table.
/// \ingroup container
///
/// This function works exactly like RfcGetTable(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in index The index of the field to read.
/// \out *tableHandle A handle to the sub-table.
/// \out *errorInfo Field does not exist, is of wrong type or out of memory.
/// \return RFC_RC
    pub fn RfcGetTableByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                              index: ::std::os::raw::c_uint,
                              tableHandle: *mut RFC_TABLE_HANDLE,
                              errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns a handle to an abap object.
/// \ingroup container
///
/// The field specified by name must be of type RFCTYPE_ABAPOBJECT. If that field has not yet
/// been filled previously, NULL is returned.
/// \warning The memory of that data container will be released, when the parent container gets
/// destroyed. So don't destroy the returned table handle, nor continue to use it, after the
/// parent has been destroyed!
///
///
/// \in dataHandle A data container (function handle, structure handle, table handle or object handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in *name The name of the field to read.
/// \out *objHandle A handle to the object.
/// \out *errorInfo Field does not exist, is of wrong type or out of memory.
/// \return RFC_RC
    pub fn RfcGetAbapObject(dataHandle: DATA_CONTAINER_HANDLE,
                            name: *const SAP_UC,
                            objHandle: *mut RFC_ABAP_OBJECT_HANDLE,
                            errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns a handle to an abap object.
/// \ingroup container
///
/// This function works exactly like RfcGetAbapObject(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle, table handle or object handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in index The index of the field to read.
/// \out *objHandle A handle to the object.
/// \out *errorInfo Field does not exist, is of wrong type or out of memory.
/// \return RFC_RC
    pub fn RfcGetAbapObjectByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                                   index: ::std::os::raw::c_uint,
                                   objHandle: *mut RFC_ABAP_OBJECT_HANDLE,
                                   errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the length of the value of a STRING or XSTRING parameter.
/// \ingroup container
///
/// The field specified by name must be of type RFCTYPE_STRING or RFCTYPE_XSTRING. If that field is
/// of type STRING, the returned length is measured in characters, otherwise in bytes.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in *name The name of a STRING or XSTRING field.
/// \out *stringLength Length of the current field value.
/// \out *errorInfo Wrong field type?
/// \return RFC_RC
    pub fn RfcGetStringLength(dataHandle: DATA_CONTAINER_HANDLE,
                              name: *const SAP_UC,
                              stringLength: *mut ::std::os::raw::c_uint,
                              errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the length of the value of a STRING or XSTRING parameter.
/// \ingroup container
///
/// This function works exactly like RfcGetStringLength(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will read the field value of the current row.
/// \in index The index of a STRING or XSTRING field.
/// \out *stringLength Length of the current field value.
/// \out *errorInfo Wrong field type?
/// \return RFC_RC
    pub fn RfcGetStringLengthByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                                     index: ::std::os::raw::c_uint,
                                     stringLength:
                                         *mut ::std::os::raw::c_uint,
                                     errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the given char value (charValue/valueLength) into the field.
/// \ingroup container
///
/// The field specified by name needs to be of one of the following data types:
/// - RFCTYPE_CHAR
/// - RFCTYPE_STRING
/// - RFCTYPE_NUM
/// - RFCTYPE_DATE
/// - RFCTYPE_TIME
/// - RFCTYPE_INTx
/// - RFCTYPE_FLOAT
/// - RFCTYPE_BCD
/// - RFCTYPE_DECFxx
/// - RFCTYPE_BYTE
/// - RFCTYPE_XSTRING
/// \note If the target field is a numerical type, the RFC library tries to convert the string
/// to a number. If the target field has type BYTE or XSTRING, the char value will be interpreted as
/// hex encoded string representation of the bytes. Its length needs to be even in that case.\n
/// Example: the 8 characters "CAFEBABE" will be converted to 4 bytes 0xCA 0xFE 0xBA 0xBE.
///
/// If the value cannot be converted to the desired target type, RFC_CONVERSION_ERROR will be
/// returned.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *name The name of the field to set.
/// \in *charValue The characters to write into the field.
/// \in valueLength The number of characters to read from charValue.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcSetChars(dataHandle: DATA_CONTAINER_HANDLE, name: *const SAP_UC,
                       charValue: *const RFC_CHAR,
                       valueLength: ::std::os::raw::c_uint,
                       errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the given char value (charValue/valueLength) into the field.
/// \ingroup container
///
/// This function works exactly like RfcSetChars(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *index The index of the field to set.
/// \in *charValue The characters to write into the field.
/// \in valueLength The number of characters to read from charValue.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcSetCharsByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                              index: ::std::os::raw::c_uint,
                              charValue: *const RFC_CHAR,
                              valueLength: ::std::os::raw::c_uint,
                              errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the value of a NUMC field.
/// \ingroup container
///
/// The target field needs to be of type RFCTYPE_NUM.
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *name The name of the field to set.
/// \in *charValue The digits [0..9] to write into the field.
/// \in valueLength The number of characters to read from charValue.
/// \out *errorInfo More information in case the field does not exist or the parameter value is invalid.
/// \return RFC_RC
    pub fn RfcSetNum(dataHandle: DATA_CONTAINER_HANDLE, name: *const SAP_UC,
                     charValue: *const RFC_NUM,
                     valueLength: ::std::os::raw::c_uint,
                     errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the value of a NUMC field.
/// \ingroup container
///
/// This function works exactly like RfcSetNum(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *index The index of the field to set.
/// \in *charValue The digits [0..9] to write into the field.
/// \in valueLength The number of characters to read from charValue.
/// \out *errorInfo More information in case the field does not exist or the parameter value is invalid.
/// \return RFC_RC
    pub fn RfcSetNumByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                            index: ::std::os::raw::c_uint,
                            charValue: *const RFC_NUM,
                            valueLength: ::std::os::raw::c_uint,
                            errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the given string value (stringValue/valueLength) into the field.
/// \ingroup container
///
/// The field specified by name needs to be of one of the following data types:
/// - RFCTYPE_CHAR
/// - RFCTYPE_STRING
/// - RFCTYPE_NUM
/// - RFCTYPE_DATE
/// - RFCTYPE_TIME
/// - RFCTYPE_INTx
/// - RFCTYPE_FLOAT
/// - RFCTYPE_BCD
/// - RFCTYPE_DECFxx
/// - RFCTYPE_BYTE
/// - RFCTYPE_XSTRING
/// \note If the target field is a numerical type, the RFC library tries to convert the string
/// to a number. If the target field has type BYTE or XSTRING, the char value will be interpreted as
/// hex encoded string representation of the bytes. Its length needs to be even in that case.\n
/// Example: the 8 characters "CAFEBABE" will be converted to 4 bytes 0xCA 0xFE 0xBA 0xBE.
///
/// If the value cannot be converted to the desired target type, RFC_CONVERSION_ERROR will be
/// returned.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *name The name of the field to set.
/// \in *stringValue The characters to write into the field.
/// \in valueLength The number of characters to read from stringValue.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcSetString(dataHandle: DATA_CONTAINER_HANDLE,
                        name: *const SAP_UC, stringValue: *const SAP_UC,
                        valueLength: ::std::os::raw::c_uint,
                        errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the given string value (stringValue/valueLength) into the field.
/// \ingroup container
///
/// This function works exactly like RfcSetString(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *index The index of the field to set.
/// \in *stringValue The characters to write into the field.
/// \in valueLength The number of characters to read from stringValue.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcSetStringByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                               index: ::std::os::raw::c_uint,
                               stringValue: *const SAP_UC,
                               valueLength: ::std::os::raw::c_uint,
                               errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the value of a DATE field.
/// \ingroup container
///
/// The target field needs to be of type RFCTYPE_DATE.
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *name The name of the field to set.
/// \in date The date value to write into the field.
/// \out *errorInfo Is the field not of type DATE?
/// \return RFC_RC
    pub fn RfcSetDate(dataHandle: DATA_CONTAINER_HANDLE, name: *const SAP_UC,
                      date: *mut RFC_CHAR, errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the value of a DATE field.
/// \ingroup container
///
/// This function works exactly like RfcSetDate(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *index The index of the field to set.
/// \in date The date value to write into the field.
/// \out *errorInfo Is the field not of type DATE?
/// \return RFC_RC
    pub fn RfcSetDateByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                             index: ::std::os::raw::c_uint,
                             date: *mut RFC_CHAR,
                             errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the value of a TIME field.
/// \ingroup container
///
/// The target field needs to be of type RFCTYPE_TIME.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *name The name of the field to set.
/// \in time The time value to write into the field.
/// \out *errorInfo Is the field not of type TIME?
/// \return RFC_RC
    pub fn RfcSetTime(dataHandle: DATA_CONTAINER_HANDLE, name: *const SAP_UC,
                      time: *mut RFC_CHAR, errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the value of a TIME field.
/// \ingroup container
///
/// This function works exactly like RfcSetTime(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *index The index of the field to set.
/// \in time The time value to write into the field.
/// \out *errorInfo Is the field not of type TIME?
/// \return RFC_RC
    pub fn RfcSetTimeByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                             index: ::std::os::raw::c_uint,
                             time: *mut RFC_CHAR,
                             errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the given byte value (byteValue/valueLength) into the field.
/// \ingroup container
///
/// The field specified by name needs to be of one of the following data types:
/// - RFCTYPE_BYTE
/// - RFCTYPE_XSTRING
/// - RFCTYPE_CHAR
/// - RFCTYPE_STRING
/// - RFCTYPE_INTx
/// - RFCTYPE_FLOAT
/// - RFCTYPE_BCD
/// - RFCTYPE_DECFxx
/// \note: If the target field has type CHAR or STRING, the byte value
/// will be stored as a hex representation of the bytes.\n
/// If the target field has a numerical type, the byte value will be
/// assigned only if the given valueLength matches the field length.
/// In order to use this feature, you need to know exactly what you are doing...
/// E.g. when setting 8 bytes into an RFC_FLOAT field, you need to understand the
/// IEEE floating point format. Better only use this function for setting RAW fields.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *name The name of the field to set.
/// \in *byteValue The byte value to write into the field.
/// \in valueLength The number of bytes to use from byteValue.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcSetBytes(dataHandle: DATA_CONTAINER_HANDLE, name: *const SAP_UC,
                       byteValue: *const SAP_RAW,
                       valueLength: ::std::os::raw::c_uint,
                       errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the given byte value (byteValue/valueLength) into the field.
/// \ingroup container
///
/// This function works exactly like RfcSetBytes(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *index The index of the field to set.
/// \in *byteValue The byte value to write into the field.
/// \in valueLength The number of bytes to use from byteValue.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcSetBytesByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                              index: ::std::os::raw::c_uint,
                              byteValue: *const SAP_RAW,
                              valueLength: ::std::os::raw::c_uint,
                              errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the given byte value (byteValue/valueLength) into the field.
/// \ingroup container
///
/// The field specified by name needs to be of one of the following data types:
/// - RFCTYPE_BYTE
/// - RFCTYPE_XSTRING
/// - RFCTYPE_CHAR
/// - RFCTYPE_STRING
/// - RFCTYPE_INTx
/// - RFCTYPE_FLOAT
/// - RFCTYPE_BCD
/// - RFCTYPE_DECFxx
/// \note: If the target field has type CHAR or STRING, the byte value
/// will be stored as a hex representation of the bytes.\n
/// If the target field has a numerical type, the byte value will be
/// assigned only if the given valueLength matches the field length.
/// In order to use this feature, you need to know exactly what you are doing...
/// E.g. when setting 8 bytes into an RFC_FLOAT field, you need to understand the
/// IEEE floating point format. Better only use this function for setting RAW fields.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *name The name of the field to set.
/// \in *byteValue The byte value to write into the field.
/// \in valueLength The number of bytes to use from byteValue.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcSetXString(dataHandle: DATA_CONTAINER_HANDLE,
                         name: *const SAP_UC, byteValue: *const SAP_RAW,
                         valueLength: ::std::os::raw::c_uint,
                         errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the given byte value (byteValue/valueLength) into the field.
/// \ingroup container
///
/// This function works exactly like RfcSetXString(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *index The index of the field to set.
/// \in *byteValue The byte value to write into the field.
/// \in valueLength The number of bytes to use from byteValue.
/// \out *errorInfo More information in case the field does not exist or a conversion fails.
/// \return RFC_RC
    pub fn RfcSetXStringByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                                index: ::std::os::raw::c_uint,
                                byteValue: *const SAP_RAW,
                                valueLength: ::std::os::raw::c_uint,
                                errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the value of an INT4 field.
/// \ingroup container
///
/// The target field needs to be of type RFCTYPE_INT.
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *name The name of the field to set.
/// \in value The integer value to set.
/// \out *errorInfo Field does not exist or is not of type INT4?
/// \return RFC_RC
    pub fn RfcSetInt(dataHandle: DATA_CONTAINER_HANDLE, name: *const SAP_UC,
                     value: RFC_INT, errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the value of an INT4 field.
/// \ingroup container
///
/// This function works exactly like RfcSetInt(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *index The index of the field to set.
/// \in value The integer value to set.
/// \out *errorInfo Field does not exist or is not of type INT4?
/// \return RFC_RC
    pub fn RfcSetIntByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                            index: ::std::os::raw::c_uint, value: RFC_INT,
                            errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the value of an INT1 field.
/// \ingroup container
///
/// The target field needs to be of type RFCTYPE_INT1.
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *name The name of the field to set.
/// \in value The integer value to set.
/// \out *errorInfo Field does not exist or is not of type INT1?
/// \return RFC_RC
    pub fn RfcSetInt1(dataHandle: DATA_CONTAINER_HANDLE, name: *const SAP_UC,
                      value: RFC_INT1, errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the value of an INT1 field.
/// \ingroup container
///
/// This function works exactly like RfcSetInt1(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *index The index of the field to set.
/// \in value The integer value to set.
/// \out *errorInfo Field does not exist or is not of type INT1?
/// \return RFC_RC
    pub fn RfcSetInt1ByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                             index: ::std::os::raw::c_uint, value: RFC_INT1,
                             errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the value of an INT2 field.
/// \ingroup container
///
/// The target field needs to be of type RFCTYPE_INT2.
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *name The name of the field to set.
/// \in value The integer value to set.
/// \out *errorInfo Field does not exist or is not of type INT2?
/// \return RFC_RC
    pub fn RfcSetInt2(dataHandle: DATA_CONTAINER_HANDLE, name: *const SAP_UC,
                      value: RFC_INT2, errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the value of an INT2 field.
/// \ingroup container
///
/// This function works exactly like RfcSetInt2(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *index The index of the field to set.
/// \in value The integer value to set.
/// \out *errorInfo Field does not exist or is not of type INT2?
/// \return RFC_RC
    pub fn RfcSetInt2ByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                             index: ::std::os::raw::c_uint, value: RFC_INT2,
                             errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets a floating point field.
/// \ingroup container
///
/// The field specified by name needs to be of one of the following data types:
/// - RFCTYPE_FLOAT
/// - RFCTYPE_BCD
/// - RFCTYPE_CHAR
/// - RFCTYPE_STRING
/// - RFCTYPE_NUM
/// - RFCTYPE_DECF16
/// - RFCTYPE_DECF34
/// \note If the target field is CHAR or STRING, the value will be converted to a string in
/// scientific notation. If it is NUMC, it will be truncated to the next integer.
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *name The name of the field to set.
/// \in value The double value to set.
/// \out *errorInfo Field does not exist or is not of a supported type?
/// \return RFC_RC
    pub fn RfcSetFloat(dataHandle: DATA_CONTAINER_HANDLE, name: *const SAP_UC,
                       value: RFC_FLOAT, errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Sets a floating point field.
/// \ingroup container
///
/// This function works exactly like RfcSetFloat(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *index The index of the field to set.
/// \in value The double value to set.
/// \out *errorInfo Field does not exist or is not of a supported type?
/// \return RFC_RC
    pub fn RfcSetFloatByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                              index: ::std::os::raw::c_uint, value: RFC_FLOAT,
                              errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the value of an 8 byte decfloat object into a field.
/// \ingroup container
///
/// The field specified by name needs to be of one of the following data types:
/// - RFCTYPE_DECF16
/// - RFCTYPE_DECF34
/// - RFCTYPE_FLOAT
/// - RFCTYPE_BCD
/// - RFCTYPE_INT
/// - RFCTYPE_INT2
/// - RFCTYPE_INT1
/// - RFCTYPE_CHAR
/// - RFCTYPE_NUM
/// - RFCTYPE_STRING
/// - RFCTYPE_BYTE     Needs to be 8 byte long.
/// - RFCTYPE_XSTRING
/// \note If the target field is CHAR or STRING, the value will be converted to a string in
/// scientific notation. If it is NUMC, it will be truncated to the next integer.
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *name The name of the field to set.
/// \in value The decfloat value to set.
/// \out *errorInfo Field does not exist or is not of a supported type?
/// \return RFC_RC
    pub fn RfcSetDecF16(dataHandle: DATA_CONTAINER_HANDLE,
                        name: *const SAP_UC, value: RFC_DECF16,
                        errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the value of an 8 byte decfloat object into a field.
/// \ingroup container
///
/// This function works exactly like RfcSetDecF16(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *index The index of the field to set.
/// \in value The decfloat value to set.
/// \out *errorInfo Field does not exist or is not of a supported type?
/// \return RFC_RC
    pub fn RfcSetDecF16ByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                               index: ::std::os::raw::c_uint,
                               value: RFC_DECF16,
                               errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the value of a 16 byte decfloat object into a field.
/// \ingroup container
///
/// The field specified by name needs to be of one of the following data types:
/// - RFCTYPE_DECF16
/// - RFCTYPE_DECF34
/// - RFCTYPE_FLOAT
/// - RFCTYPE_BCD
/// - RFCTYPE_INT
/// - RFCTYPE_INT2
/// - RFCTYPE_INT1
/// - RFCTYPE_CHAR
/// - RFCTYPE_NUM
/// - RFCTYPE_STRING
/// - RFCTYPE_BYTE     Needs to be 8 byte long.
/// - RFCTYPE_XSTRING
/// \note If the target field is CHAR or STRING, the value will be converted to a string in
/// scientific notation. If it is NUMC, it will be truncated to the next integer.
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *name The name of the field to set.
/// \in value The decfloat value to set.
/// \out *errorInfo Field does not exist or is not of a supported type?
/// \return RFC_RC
    pub fn RfcSetDecF34(dataHandle: DATA_CONTAINER_HANDLE,
                        name: *const SAP_UC, value: RFC_DECF34,
                        errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the value of a 16 byte decfloat object into a field.
/// \ingroup container
///
/// This function works exactly like RfcSetDecF34(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *index The index of the field to set.
/// \in value The decfloat value to set.
/// \out *errorInfo Field does not exist or is not of a supported type?
/// \return RFC_RC
    pub fn RfcSetDecF34ByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                               index: ::std::os::raw::c_uint,
                               value: RFC_DECF34,
                               errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Copies the given structure into the target structure of the parent container.
/// \ingroup container
///
/// The target field needs to be of type RFCTYPE_STRUCTURE.
///
/// \note If you want to avoid the copy operation, use RfcGetStructure() and set the subfields here,
/// instead of the sequence RfcCreateStructure()/ setting the subfields/ #RfcSetStructure().
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *name The name of the field to set.
/// \in value The structure to copy.
/// \out *errorInfo Out of memory, field does not exist or is not of type RFCTYPE_STRUCTURE?
/// \return RFC_RC
    pub fn RfcSetStructure(dataHandle: DATA_CONTAINER_HANDLE,
                           name: *const SAP_UC, value: RFC_STRUCTURE_HANDLE,
                           errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Copies the given structure into the target structure of the parent container.
/// \ingroup container
///
/// This function works exactly like RfcSetStructure(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *index The index of the field to set.
/// \in value The structure to copy.
/// \out *errorInfo Out of memory, field does not exist or is not of type RFCTYPE_STRUCTURE?
/// \return RFC_RC
    pub fn RfcSetStructureByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                                  index: ::std::os::raw::c_uint,
                                  value: RFC_STRUCTURE_HANDLE,
                                  errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Copies the given table into the target table of the parent container.
/// \ingroup container
///
/// The target field needs to be of type RFCTYPE_TABLE.
///
/// \note If you want to avoid the copy operation, use RfcGetTable() and set the subfields here,
/// instead of the sequence RfcCreateTable()/ setting the subfields/ #RfcSetTable().
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *name The name of the field to set.
/// \in value The table to copy.
/// \out *errorInfo Field does not exist or is not of type RFCTYPE_TABLE?
/// \return RFC_RC
    pub fn RfcSetTable(dataHandle: DATA_CONTAINER_HANDLE, name: *const SAP_UC,
                       value: RFC_TABLE_HANDLE,
                       errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Copies the given table into the target table of the parent container.
/// \ingroup container
///
/// This function works exactly like RfcSetTable(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle or table handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *index The index of the field to set.
/// \in value The table to copy.
/// \out *errorInfo Field does not exist or is not of type RFCTYPE_TABLE?
/// \return RFC_RC
    pub fn RfcSetTableByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                              index: ::std::os::raw::c_uint,
                              value: RFC_TABLE_HANDLE,
                              errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Copies the object into the target object of the parent container.
/// \ingroup container
///
/// The target field needs to be of type RFCTYPE_ABAPOBJECT.
///
/// \note If you want to avoid the copy operation, use RfcGetAbapObject() and if the instance already exists set the subfields here,
/// instead of the sequence RfcCreateAbapObject()/ setting the subfields/ #RfcSetAbapObject().
///
/// \in dataHandle A data container (function handle, structure handle, table handle or object handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *name The name of the field to set.
/// \in value The object to copy.
/// \out *errorInfo Field does not exist or is not of type RFCTYPE_ABAPOBJECT?
/// \return RFC_RC
    pub fn RfcSetAbapObject(dataHandle: DATA_CONTAINER_HANDLE,
                            name: *const SAP_UC,
                            value: RFC_ABAP_OBJECT_HANDLE,
                            errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Copies the object into the target object of the parent container.
/// \ingroup container
///
/// This function works exactly like RfcSetAbapObject(), the difference being that the field is
/// addressed by its index within the structure/table/function module. The first field has index 0,
/// last field has index n-1, the order of the fields is as defined in the ABAP DDIC.
///
///
/// \in dataHandle A data container (function handle, structure handle, table handle or object handle). If dataHandle
/// is a table handle, the function will set the field value of the current row.
/// \in *index The index of the field to set.
/// \in value The object to copy.
/// \out *errorInfo Field does not exist or is not of type RFCTYPE_ABAPOBJECT?
/// \return RFC_RC
    pub fn RfcSetAbapObjectByIndex(dataHandle: DATA_CONTAINER_HANDLE,
                                   index: ::std::os::raw::c_uint,
                                   value: RFC_ABAP_OBJECT_HANDLE,
                                   errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Gets the ABAP exception object handle from the given function handle.
/// \ingroup container
///
/// If a call to #RfcInvoke() returned RFC_ABAP_CLASS_EXCEPTION, the RFC client calls this function afterwards with the original function handle
/// in order to get access to the details of the class exception.
/// \in funcHandle   Function module data container.
/// \out *errorInfo  Should always return successfully.
/// \return A handle to an ABAP class exception object .
    pub fn RfcGetAbapClassException(funcHandle: RFC_FUNCTION_HANDLE,
                                    errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_ABAP_OBJECT_HANDLE;
}
extern "C" {
    /// \brief  Sets the ABAP exception object handle to the given function handle.
/// \ingroup container
///
/// If an RFC server function wants to throw an ABAP class exception, it calls this function before it returns with RFC_ABAP_CLASS_EXCEPTION.
/// \in funcHandle   Function module data container .
/// \in excpHandle   Object handle to the class exception to be thrown.
/// \in exceptionText  Exception text.
/// \out *errorInfo  Should always return successfully.
/// \return RFC_RC
    pub fn RfcSetAbapClassException(funcHandle: RFC_FUNCTION_HANDLE,
                                    excpHandle: RFC_ABAP_OBJECT_HANDLE,
                                    exceptionText: *const SAP_UC,
                                    errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the metadata description for the given function module.
/// \ingroup container
///
///
/// \in funcHandle A function module.
/// \out *errorInfo Can't possibly go wrong...
/// \return The metadata description that had been used when creating the function module container.
    pub fn RfcDescribeFunction(funcHandle: RFC_FUNCTION_HANDLE,
                               errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_FUNCTION_DESC_HANDLE;
}
extern "C" {
    /// \brief  Returns the metadata description of the given structure or table (RFC_STRUCTURE_HANDLE or RFC_TABLE_HANDLE).
/// \ingroup container
///
///
/// \in dataHandle A structure or table.
/// \out *errorInfo Can't possibly go wrong...
/// \return The type description of the given structure (in case dataHandle is a structure), or the
/// type description of the table line type (in case dataHandle is a table).
    pub fn RfcDescribeType(dataHandle: DATA_CONTAINER_HANDLE,
                           errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_TYPE_DESC_HANDLE;
}
extern "C" {
    /// \brief  Returns the function description that is valid for the system to which rfcHandle points to.
/// \ingroup repository
///
/// If the function description is already in the repository cache for that system ID, it will be
/// returned immediately (from the cache), otherwise it will be looked up in the system's DDIC using
/// the rfcHandle. The result from the DDIC lookup will then be placed into the cache for later use.
///
/// The RFC Runtime maintains a cache for every R/3 System ID, as the meta data could be different
/// from R/3 release to R/3 release.
/// This is the main API that should be used.
///
/// \in rfcHandle Open client connection to the R/3 System, for which you need the function module description.
/// \in *funcName Name of the function module to look up.
/// \out *errorInfo More error details in case something goes wrong.
/// \return The metadata description of the given function module.
    pub fn RfcGetFunctionDesc(rfcHandle: RFC_CONNECTION_HANDLE,
                              funcName: *const SAP_UC,
                              errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_FUNCTION_DESC_HANDLE;
}
extern "C" {
    /// \brief  Looks for a cached function description.
/// \ingroup repository
///
/// This API should be used with care and is only for special scenarios, for example:
/// 1. You know for sure, that a function description has already been cached via RfcGetFunctionDesc(),
/// and don't want to open an extra rfcHandle that will never be used.
/// In this case simply use the SAP System ID as the repositoryID.
/// 2. You have created a hard-coded repository via RfcAddFunctionDesc(), which contains function modules
/// that do not exist in the backend's DDIC.
///
/// If repositoryID is NULL, the "default repository" is used.
///
/// \in *repositoryID System ID of R/3 System, for which this function module description has been cached,
/// or NULL in case you want to look for it in the default repository.
/// \in *funcName Name of the function module.
/// \out *errorInfo Requested function name not in cache?
/// \return The requested function description.
    pub fn RfcGetCachedFunctionDesc(repositoryID: *const SAP_UC,
                                    funcName: *const SAP_UC,
                                    errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_FUNCTION_DESC_HANDLE;
}
extern "C" {
    /// \brief  Adds a function description to the cache for the specified R/3 System.
/// \ingroup repository
///
/// This API should be used with care and is only for special scenarios, e.g. if you want to
/// write an RFC server that offers function modules, which do not exist in the R/3 system's DDIC.
/// If repositoryID is NULL, the description is added to the "default repository".
///
///
/// \in *repositoryID System ID of R/3 System, to whose cache you want to add the function description,
/// or NULL for the default repository.
/// \in funcDesc The function description.
/// \out *errorInfo Not much that can go wrong here.
/// \return RFC_RC
    pub fn RfcAddFunctionDesc(repositoryID: *const SAP_UC,
                              funcDesc: RFC_FUNCTION_DESC_HANDLE,
                              errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Removes a function description from the cache for the specified R/3 System.
/// \ingroup repository
///
/// This API can be used, e.g. if the signature (imports, exports, etc.) of a function module has
/// been changed in the backend, while the external RFC program is still running. If the RFC library
/// continues using the old cached metadata description, garbage values (if fields have been deleted
/// from the function module) or missing values (if new fields have been added to the function module)
/// will result.
/// If repositoryID is NULL, the description is removed from the "default repository".
///
///
/// \in *repositoryID System ID of R/3 System, to whose cache you want to add the function description,
/// or NULL for the default repository.
/// \in *functionName The name of the function module, whose description is to be removed from the cache.
/// \out *errorInfo Not much that can go wrong here.
/// \return RFC_RC
    pub fn RfcRemoveFunctionDesc(repositoryID: *const SAP_UC,
                                 functionName: *const SAP_UC,
                                 errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the structure description that is valid for the system to which rfcHandle points to.
/// \ingroup repository
///
/// If the structure description is already in the repository cache for that system ID, it will be
/// returned immediately (from the cache), otherwise it will be looked up in the system's DDIC using
/// the rfcHandle. The result from the DDIC lookup will then be placed into the cache for later use.
///
/// The RFC Runtime maintains a cache for every R/3 System ID, as the meta data could be different
/// from R/3 release to R/3 release.
/// \note Normally it should not be necessary to lookup separate structure descriptions. They are
/// already looked up as part of the function module, in which they are used.
///
/// \in rfcHandle Open client connection to the R/3 System, for which you need the structure description.
/// \in *typeName Name of a DDIC structure or table.
/// \out *errorInfo More error details in case something goes wrong.
/// \return The metadata description of the given structure/table.
    pub fn RfcGetTypeDesc(rfcHandle: RFC_CONNECTION_HANDLE,
                          typeName: *const SAP_UC,
                          errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_TYPE_DESC_HANDLE;
}
extern "C" {
    /// \brief  Looks for a cached structure/table description.
/// \ingroup repository
///
/// Similar to RfcGetTypeDesc(), but it only looks into the cache. Again it should almost never
/// be necessary to get a metadata description of a single structure.
///
/// \in *repositoryID System ID of R/3 System, for which this type description has been cached,
/// or NULL in case you want to look for it in the default repository.
/// \in *typeName Name of the DDIC structure/table.
/// \out *errorInfo Requested type name not in cache?
/// \return The requested type description.
    pub fn RfcGetCachedTypeDesc(repositoryID: *const SAP_UC,
                                typeName: *const SAP_UC,
                                errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_TYPE_DESC_HANDLE;
}
extern "C" {
    /// \brief  Adds a type description to the cache.
/// \ingroup repository
///
///
/// \in *repositoryID System ID of R/3 System, to whose cache you want to add the type description,
/// or NULL for the default repository.
/// \in typeHandle The type description.
/// \out *errorInfo Not much that can go wrong here.
/// \return RFC_RC
    pub fn RfcAddTypeDesc(repositoryID: *const SAP_UC,
                          typeHandle: RFC_TYPE_DESC_HANDLE,
                          errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Removes a type description from the cache.
/// \ingroup repository
///
///
/// \in *repositoryID System ID of R/3 System, from whose cache you want to remove the type description,
/// or NULL for the default repository.
/// \in *typeName The name of the type, whose description is to be removed from the cache.
/// \out *errorInfo Not much that can go wrong here.
/// \return RFC_RC
    pub fn RfcRemoveTypeDesc(repositoryID: *const SAP_UC,
                             typeName: *const SAP_UC,
                             errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the class description that is valid for the system to which rfcHandle points to.
/// \ingroup repository
///
/// If the class description is already in the repository cache for that system ID, it will be
/// returned immediately (from the cache), otherwise it will be looked up in the system's DDIC using
/// the rfcHandle. The result from the DDIC lookup will then be placed into the cache for later use.
///
/// The RFC Runtime maintains a cache for every R/3 System ID, as the meta data could be different
/// from R/3 release to R/3 release.
/// This is the main API that should be used.
///
/// \in rfcHandle Open client connection to the R/3 System, for which you need the class description.
/// \in *className Name of the class to look up.
/// \out *errorInfo More error details in case something goes wrong.
/// \return The metadata description of the given function module.
    pub fn RfcGetClassDesc(rfcHandle: RFC_CONNECTION_HANDLE,
                           className: *const SAP_UC,
                           errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_CLASS_DESC_HANDLE;
}
extern "C" {
    /// \brief  Looks for a cached class description.
/// \ingroup repository
///
/// This API should be used with care and is only for special scenarios, for example:
/// 1. You know for sure, that a class description has already been cached via RfcGetClassDesc(),
/// and don't want to open an extra rfcHandle that will never be used.
/// In this case simply use the SAP System ID as the repositoryID.
/// 2. You have created a hard-coded repository via RfcAddClassDesc(), which contains classes
/// that do not exist in the backend's DDIC.
///
/// If repositoryID is NULL, the "default repository" is used.
///
/// \in *repositoryID System ID of R/3 System, for which this class description has been cached,
/// or NULL in case you want to look for it in the default repository.
/// \in *className Name of the class.
/// \out *errorInfo Requested class name not in cache?
/// \return The requested class description.
    pub fn RfcGetCachedClassDesc(repositoryID: *const SAP_UC,
                                 className: *const SAP_UC,
                                 errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_CLASS_DESC_HANDLE;
}
extern "C" {
    /// \brief  Returns the metadata description of the given ABAP object handle.
/// \ingroup container
///
///
/// \in objectHandle An ABAP object.
/// \out *errorInfo Can't possibly go wrong...
/// \return The class description of the given ABAP object.
    pub fn RfcDescribeAbapObject(objectHandle: RFC_ABAP_OBJECT_HANDLE,
                                 errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_CLASS_DESC_HANDLE;
}
extern "C" {
    /// \brief  Adds a class description to the cache for the specified R/3 System.
/// \ingroup repository
///
/// This API should be used with care and is only for special scenarios, e.g. if you want to
/// write an RFC server that offers/uses classes, which do not exist in the R/3 system's DDIC.
/// If repositoryID is NULL, the description is added to the "default repository".
///
///
/// \in *repositoryID System ID of R/3 System, to whose cache you want to add the class description,
/// or NULL for the default repository.
/// \in classDesc The class description.
/// \out *errorInfo Not much that can go wrong here.
/// \return RFC_RC
    pub fn RfcAddClassDesc(repositoryID: *const SAP_UC,
                           classDesc: RFC_CLASS_DESC_HANDLE,
                           errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Removes a class description from the cache for the specified R/3 System.
/// \ingroup repository
///
/// If repositoryID is NULL, the description is added to the "default repository".
///
///
/// \in *repositoryID System ID of R/3 System, from whose cache you want to remove the class description,
/// or NULL for the default repository.
/// \in *className The name of the ABAP class, whose description you want to remove.
/// \out *errorInfo Not much that can go wrong here.
/// \return RFC_RC
    pub fn RfcRemoveClassDesc(repositoryID: *const SAP_UC,
                              className: *const SAP_UC,
                              errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Creates an empty type description with the given name.
/// \ingroup structure
///
/// API for creating hard-coded metadata descriptions, e.g. for function modules that
/// don't exist in the R/3 backend.
/// Add field descriptions to the type description using RfcAddTypeField() and at the end
/// set the total byte length of the structure using RfcSetTypeLength().
/// \warning It is not easy to get the total length right, as you also need to take
/// alignment bytes into account...
///
/// Finished type definitions can then be used for creating data containers (RfcCreateStructure()
/// or RfcCreateTable()) and for adding field/table descriptions to a function module description
/// (in RFC_PARAMETER_DESCs in RfcAddParameter()).
///
/// After the handle was used for creating a container, any modifications are forbidden.
///
/// \in *name An (arbitrary) name for the type.
/// \out *errorInfo Not enough memory?
/// \return The new type description.
    pub fn RfcCreateTypeDesc(name: *const SAP_UC,
                             errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_TYPE_DESC_HANDLE;
}
extern "C" {
    /// \brief  Adds a new field to the type description.
/// \ingroup structure
///
/// \note After a type description has been used (e.g. via RfcCreateStructure(), RfcCreateTable() or
/// RfcAddTypeDesc()), it can no longer be modified!
///
/// \in typeHandle
/// \in *fieldDescr
/// \out *errorInfo
/// \return RFC_RC
    pub fn RfcAddTypeField(typeHandle: RFC_TYPE_DESC_HANDLE,
                           fieldDescr: *const RFC_FIELD_DESC,
                           errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the total byte length of the type description.
/// \ingroup structure
///
/// Before a type description can be used, this function needs to be called.
/// The RFC library does not automatically calculate the correct length based on
/// the fields that have been added, because this task is non-trivial and possibly
/// platform dependend. (Especially if the structure contains sub-structures.)\n
/// For integer and floating point types the correct alignments need to be taken into
/// account (start address divisible by 4 or 8), fixed sub-structures are inlined,
/// complex structures are referenced by an 8-byte pointer, etc. In general you will need
/// to do a bit of trial and error, before you get it right.\n
/// If you really need more details/tips for the process of hardcoding metadata, see
/// <A HREF="https://scn.sap.com/docs/DOC-52888">this article</A>.
///
///
/// \in typeHandle The type description.
/// \in nucByteLength Total byte length of the structure in a non-Unicode system (1 byte per CHAR).
/// \in ucByteLength Total byte length of the structure in a Unicode system (2 bytes per CHAR).
/// \out *errorInfo The function returns an error, if the given byte lengths are smaller than
/// the sum of all field lengths, or if the nucByteLength is smaller than the ucByteLength.
/// \return RFC_RC
    pub fn RfcSetTypeLength(typeHandle: RFC_TYPE_DESC_HANDLE,
                            nucByteLength: ::std::os::raw::c_uint,
                            ucByteLength: ::std::os::raw::c_uint,
                            errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the name of the type.
/// \ingroup structure
///
///
/// \in typeHandle The type description.
/// \out bufferForName Will receive the null-terminated DDIC name of the structure definition.
/// \out *errorInfo Should always return successfully...
/// \return RFC_RC
    pub fn RfcGetTypeName(typeHandle: RFC_TYPE_DESC_HANDLE,
                          bufferForName: *mut RFC_CHAR,
                          errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the number of fields in a structure definition.
/// \ingroup structure
///
///
/// \in typeHandle The type description.
/// \out *count The number of (direct) fields of this structure.
/// \out *errorInfo Should always return successfully...
/// \return RFC_RC
    pub fn RfcGetFieldCount(typeHandle: RFC_TYPE_DESC_HANDLE,
                            count: *mut ::std::os::raw::c_uint,
                            errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Reads the field description of the structure's ith field.
/// \ingroup structure
///
/// Useful mostly when looping over the fields of a structure.
///
/// \in typeHandle The type description.
/// \in index The index of the field you are interested in.
/// \out *fieldDescr Will be filled with field's description.
/// \out *errorInfo Index out of bounds?
/// \return RFC_RC
    pub fn RfcGetFieldDescByIndex(typeHandle: RFC_TYPE_DESC_HANDLE,
                                  index: ::std::os::raw::c_uint,
                                  fieldDescr: *mut RFC_FIELD_DESC,
                                  errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Reads the field description of a field given by name.
/// \ingroup structure
///
///
/// \in typeHandle The type description.
/// \in *name The name of the field of interest.
/// \out *fieldDescr Will be filled with field's description.
/// \out *errorInfo No such field?
/// \return RFC_RC
    pub fn RfcGetFieldDescByName(typeHandle: RFC_TYPE_DESC_HANDLE,
                                 name: *const SAP_UC,
                                 fieldDescr: *mut RFC_FIELD_DESC,
                                 errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the total byte length of a structure definition.
/// \ingroup structure
///
///
/// \in typeHandle The type description.
/// \out nucByteLength Total byte length in a non-Unicode system.
/// \out ucByteLength Total byte length in a Unicode system.
/// \out *errorInfo Should always return successfully.
/// \return RFC_RC
    pub fn RfcGetTypeLength(typeHandle: RFC_TYPE_DESC_HANDLE,
                            nucByteLength: *mut ::std::os::raw::c_uint,
                            ucByteLength: *mut ::std::os::raw::c_uint,
                            errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Deletes the type description and releases the allocated resources.
/// \ingroup structure
///
/// Only descriptions, which are not stored in a repository cache and not used by the application, can be deleted.
/// Deleting a cached description will cause an error, and deleting a description that is still in use, will lead
/// to a crash.
///
///
/// \inout typeHandle The type description to be deleted.
/// \out *errorInfo
/// \return
    pub fn RfcDestroyTypeDesc(typeHandle: RFC_TYPE_DESC_HANDLE,
                              errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Creates an empty function description with the given name.
/// \ingroup function
///
/// Add parameter descriptions and exception descriptions to the new RFC_FUNCTION_DESC_HANDLE
/// via RfcAddParameter() and RfcAddException().\n
///
/// After the handle was used for creating a container, any modifications are forbidden.
///
/// \in *name The name of the function module.
/// \out *errorInfo Probably not enough memory left?!
/// \return An empty function description that can be used for constructing hard-coded metadata.
    pub fn RfcCreateFunctionDesc(name: *const SAP_UC,
                                 errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_FUNCTION_DESC_HANDLE;
}
extern "C" {
    /// \brief  Returns a function module's DDIC name.
/// \ingroup function
///
///
/// \in funcDesc The function module description.
/// \out bufferForName Will receive the function module's DDIC name.
/// \out *errorInfo Should always return successfully.
/// \return RFC_RC
    pub fn RfcGetFunctionName(funcDesc: RFC_FUNCTION_DESC_HANDLE,
                              bufferForName: *mut RFC_CHAR,
                              errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Adds a new parameter (IMPORTING, EXPORTING, CHANGING, TABLES) to the function description.
/// \ingroup function
///
/// \note After the function description has been used via RfcCreateFunction() or RfcAddFunctionDesc(),
/// it can no longer be modified!
///
/// \in funcDesc The function module description.
/// \in *paramDescr Metadata description of the new parameter.
/// \out *errorInfo More details in case something goes wrong.
/// \return RFC_RC
    pub fn RfcAddParameter(funcDesc: RFC_FUNCTION_DESC_HANDLE,
                           paramDescr: *const RFC_PARAMETER_DESC,
                           errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the number of parameters in the function module definition.
/// \ingroup function
///
///
/// \in funcDesc The function module's metadata description.
/// \out *count The number of parameters (IMPORTING, EXPORTING, CHANGING, TABLES).
/// \out *errorInfo Nothing can go wrong here.
/// \return RFC_RC
    pub fn RfcGetParameterCount(funcDesc: RFC_FUNCTION_DESC_HANDLE,
                                count: *mut ::std::os::raw::c_uint,
                                errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Reads the metadata description of the function module's ith parameter.
/// \ingroup function
///
/// \note Mostly be useful when looping over all parameters of a function module.
///
/// \in funcDesc The function module's metadata description.
/// \in index The index of the parameter to describe.
/// \out *paramDesc Metadata description of the specified parameter.
/// \out *errorInfo Index out of bounds?
/// \return RFC_RC
    pub fn RfcGetParameterDescByIndex(funcDesc: RFC_FUNCTION_DESC_HANDLE,
                                      index: ::std::os::raw::c_uint,
                                      paramDesc: *mut RFC_PARAMETER_DESC,
                                      errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Reads the metadata description of a function module parameter given by name.
/// \ingroup function
///
///
/// \in funcDesc The function module's metadata description.
/// \in *name The name of the parameter to describe.
/// \out *paramDesc Metadata description of the specified parameter.
/// \out *errorInfo No such parameter?
/// \return RFC_RC
    pub fn RfcGetParameterDescByName(funcDesc: RFC_FUNCTION_DESC_HANDLE,
                                     name: *const SAP_UC,
                                     paramDesc: *mut RFC_PARAMETER_DESC,
                                     errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Adds a new ABAP Exception to the function description.
/// \ingroup function
///
/// \note After the function description has been used via RfcCreateFunction() or RfcAddFunctionDesc(),
/// it can no longer be modified!
///
///
/// \in funcDesc The function module's metadata description.
/// \in *excDesc The description of the exception to add.
/// \out *errorInfo Not much that can go wrong here.
/// \return RFC_RC
    pub fn RfcAddException(funcDesc: RFC_FUNCTION_DESC_HANDLE,
                           excDesc: *const RFC_EXCEPTION_DESC,
                           errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the number of ABAP Exceptions of the function module.
/// \ingroup function
///
///
/// \in funcDesc The function module's metadata description.
/// \out *count The number of the function module's ABAP Exceptions.
/// \out *errorInfo Not much that can go wrong here.
/// \return RFC_RC
    pub fn RfcGetExceptionCount(funcDesc: RFC_FUNCTION_DESC_HANDLE,
                                count: *mut ::std::os::raw::c_uint,
                                errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Reads the metadata description of the function module's ith ABAP Exception.
/// \ingroup function
///
///
/// \in funcDesc The function module's metadata description.
/// \in index The index of the exception to describe.
/// \out *excDesc The ABAP Exception's metadata description.
/// \out *errorInfo Index out of bounds?
/// \return RFC_RC
    pub fn RfcGetExceptionDescByIndex(funcDesc: RFC_FUNCTION_DESC_HANDLE,
                                      index: ::std::os::raw::c_uint,
                                      excDesc: *mut RFC_EXCEPTION_DESC,
                                      errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Reads the metadata description of a function module's ABAP Exception given by name.
/// \ingroup function
///
///
/// \in funcDesc The function module's metadata description.
/// \in *name The name of the exception to describe.
/// \out *excDesc The ABAP Exception's metadata description.
/// \out *errorInfo No such ABAP Exception?
/// \return RFC_RC
    pub fn RfcGetExceptionDescByName(funcDesc: RFC_FUNCTION_DESC_HANDLE,
                                     name: *const SAP_UC,
                                     excDesc: *mut RFC_EXCEPTION_DESC,
                                     errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Enables this function module for the basXML serialization format.
/// \ingroup function
///
/// R/3 Systems from kernel release 7.10 on support a new serialization format: basXML (binary ABAP serialization).
/// Calling %RfcEnableBASXML() allows the RFC library to transport this function module's data via the
/// basXML format, if the target backend supports it.
///
/// \in funcDesc The function module's metadata description.
/// \out *errorInfo Should always return successfully.
/// \return RFC_RC
    pub fn RfcEnableBASXML(funcDesc: RFC_FUNCTION_DESC_HANDLE,
                           errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns whether this function module has been enabled for basXML.
/// \ingroup function
///
/// See RfcEnableBASXML()
///
/// \in funcDesc The function module's metadata description.
/// \out *isEnabled 0 = false, 1 = true.
/// \out *errorInfo Should always return successfully.
/// \return RFC_RC
    pub fn RfcIsBASXMLSupported(funcDesc: RFC_FUNCTION_DESC_HANDLE,
                                isEnabled: *mut ::std::os::raw::c_int,
                                errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Deletes the function description and releases the allocated resources.
/// \ingroup function
///
/// Only descriptions, which are not stored in a repository cache and not used by the application, can be deleted.
/// Deleting a cached description will cause an error, and deleting a description that is still in use, will lead
/// to a crash.
///
///
/// \in funcDesc A function description.
/// \out *errorInfo Should always return successfully...
/// \return RFC_RC
    pub fn RfcDestroyFunctionDesc(funcDesc: RFC_FUNCTION_DESC_HANDLE,
                                  errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Enables this function handle for ABAP class exception support.
/// \ingroup function
///
/// R/3 Systems from kernel release 7.11 on support ABAP class exceptions.
/// Calling %RfcEnableAbapClassException() allows an RFC client to inform the ABAP backend that it can handle ABAP class exceptions
/// for the current function call using this function handle. If the ABAP backend supports class-based exceptions as well,
/// it can now safely throw such an exception.\n
/// Needs to be called before the corresponding RfcInvoke().
///
/// \in funcHandle Function module data container.
/// \in rfcHandleRepository RFC connection handle to the repository system from where the missing metadata can be
/// dynamically retrieved during de-serializing the received ABAP class exceptions. This handle can be NULL but should not be
/// the same that is used for the RFC call itself.
/// \out *errorInfo Should always return successfully.
/// \return RFC_RC
    pub fn RfcEnableAbapClassException(funcHandle: RFC_FUNCTION_HANDLE,
                                       rfcHandleRepository:
                                           RFC_CONNECTION_HANDLE,
                                       errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Checks whether this function handle has been enabled for ABAP class exception support.
/// \ingroup function
///
/// R/3 Systems from kernel release 7.11 on support ABAP class exception.
/// Typically, an RFC server can use this function in order to find out, whether the function module currently being processed has
/// ABAP class exceptions enabled in the ABAP backend. Only if this is the case, can the RFC Server safely throw an ABAP class exception.
///
/// \in funcHandle Function module data container.
/// \out *isEnabled Flag indicating whether the function handle has been enabled for ABAP class based exception support.
/// \out *errorInfo Should always return successfully.
/// \return RFC_RC
    pub fn RfcIsAbapClassExceptionEnabled(funcHandle: RFC_FUNCTION_HANDLE,
                                          isEnabled:
                                              *mut ::std::os::raw::c_int,
                                          errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Creates an empty class description with the given name.
/// \ingroup class
///
/// Add attribute descriptions to the new RFC_CLASS_DESC_HANDLE via RfcAddAttribute().\n
///
/// After the handle was used for creating a container, any modifications are forbidden.
///
/// \in *name The name of the ABAP class.
/// \out *errorInfo Probably not enough memory left?!
/// \return An empty function description that can be used for constructing hard-coded metadata.
    pub fn RfcCreateClassDesc(name: *const SAP_UC,
                              errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_CLASS_DESC_HANDLE;
}
extern "C" {
    /// \brief  Returns the class's DDIC name.
/// \ingroup class
///
///
/// \in classDesc The class description.
/// \out bufferForName Will receive the function module's DDIC name (zero terminated).
/// \out *errorInfo Should always return successfully.
/// \return RFC_RC
    pub fn RfcGetClassName(classDesc: RFC_CLASS_DESC_HANDLE,
                           bufferForName: *mut RFC_CHAR,
                           errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Adds a new attribute (field, structure, table, method) to the class description.
/// \ingroup class
///
/// \note After the function description has been used via RfcCreateAbapObject() or RfcAddClassDesc(),
/// it can no longer be modified!
///
/// \in classDesc The class description.
/// \in *attrDesc Metadata description of the new class attribute.
/// \out *errorInfo More details in case something goes wrong.
/// \return RFC_RC
    pub fn RfcAddClassAttribute(classDesc: RFC_CLASS_DESC_HANDLE,
                                attrDesc: *const RFC_CLASS_ATTRIBUTE_DESC,
                                errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the number of parameters in the function module definition.
/// \ingroup class
///
///
/// \in classDesc The class description.
/// \out *count The number of attributes.
/// \out *errorInfo Nothing can go wrong here.
/// \return RFC_RC
    pub fn RfcGetClassAttributesCount(classDesc: RFC_CLASS_DESC_HANDLE,
                                      count: *mut ::std::os::raw::c_uint,
                                      errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Reads the metadata description of the class attribute.
/// \ingroup class
///
/// \note Is useful mostly when looping over all attributes of a class.
///
/// \in classDesc The class metadata description.
/// \in index The index of the attributes to describe.
/// \out *attrDesc Metadata description of the class attribute.
/// \out *errorInfo Index out of bounds?
/// \return RFC_RC
    pub fn RfcGetClassAttributeDescByIndex(classDesc: RFC_CLASS_DESC_HANDLE,
                                           index: ::std::os::raw::c_uint,
                                           attrDesc:
                                               *mut RFC_CLASS_ATTRIBUTE_DESC,
                                           errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Reads the metadata description of a class attribute given by name.
/// \ingroup class
///
///
/// \in classDesc The class metadata description.
/// \in *name The name of the parameter to describe.
/// \out *attrDesc Metadata description of the class attribute.
/// \out *errorInfo No such parameter?
/// \return RFC_RC
    pub fn RfcGetClassAttributeDescByName(classDesc: RFC_CLASS_DESC_HANDLE,
                                          name: *const SAP_UC,
                                          attrDesc:
                                              *mut RFC_CLASS_ATTRIBUTE_DESC,
                                          errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the parent classes of the given class.
/// \ingroup class
///
/// \in classDesc The class metadata description.
/// \in name The parent class name.
/// \in index Index of parent class.
/// \out *errorInfo Current class does not inherit from parent class?
/// \return RFC_RC
    pub fn RfcGetParentClassByIndex(classDesc: RFC_CLASS_DESC_HANDLE,
                                    name: *mut RFC_CHAR,
                                    index: ::std::os::raw::c_uint,
                                    errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the number of parent classes of the given class.
/// \ingroup class
///
///
/// \in classDesc The class metadata description.
/// \out *parentClassesCount Number of parent classes in the list.
/// \out *errorInfo Should always be successful.
/// \return RFC_RC
    pub fn RfcGetParentClassesCount(classDesc: RFC_CLASS_DESC_HANDLE,
                                    parentClassesCount:
                                        *mut ::std::os::raw::c_uint,
                                    errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Sets the parent classes of the given class.
/// \ingroup class
///
///
/// \in classDesc The class metadata description.
/// \in name Parent class name to be added.
/// \out *errorInfo No such parameter?
/// \return RFC_RC
    pub fn RfcAddParentClass(classDesc: RFC_CLASS_DESC_HANDLE,
                             name: *mut RFC_CHAR,
                             errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the implemented interfaces of the given class.
/// \ingroup class
///
///
/// \in classDesc The class metadata description.
/// \in index Index of the implemented interface.
/// \out name Buffer for the implemented interface's name.
/// \out *errorInfo Index out of bounds?
/// \return RFC_RC
    pub fn RfcGetImplementedInterfaceByIndex(classDesc: RFC_CLASS_DESC_HANDLE,
                                             index: ::std::os::raw::c_uint,
                                             name: *mut RFC_CHAR,
                                             errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the number of parent interfaces of the given class.
/// \ingroup class
///
///
/// \in classDesc The class metadata description.
/// \out *implementedInterfacesCount Number of implemented interfaces.
/// \out *errorInfo Should always be successful.
/// \return RFC_RC
    pub fn RfcGetImplementedInterfacesCount(classDesc: RFC_CLASS_DESC_HANDLE,
                                            implementedInterfacesCount:
                                                *mut ::std::os::raw::c_uint,
                                            errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Adds an interface to the list of implemented interfaces of the given class.
/// \ingroup class
///
///
/// \in classDesc The class metadata description.
/// \in name Name of implemented interface to be added.
/// \out *errorInfo Not much can go wrong here except out of memory.
/// \return RFC_RC
    pub fn RfcAddImplementedInterface(classDesc: RFC_CLASS_DESC_HANDLE,
                                      name: *mut RFC_CHAR,
                                      errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Deletes the class description and releases the allocated resources.
/// \ingroup class
///
/// Only descriptions, which are not stored in a repository cache and not used by the application, can be deleted.
/// Deleting a cached description will cause an error, and deleting a description that is still in use, will lead
/// to a crash.
///
///
/// \in classHandle The class description to be deleted.
/// \out *errorInfo More details in case the description can not be destroyed.
/// \return RFC_RC
    pub fn RfcDestroyClassDesc(classHandle: RFC_CLASS_DESC_HANDLE,
                               errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
pub type RFC_METADATA_QUERY_RESULT_HANDLE = *mut ::std::os::raw::c_void;
/// \struct _RFC_METADATA_QUERY_RESULT_ENTRY
/// \ingroup repository
///
/// Structure containing the error that occurred during the metadata query.
#[repr(C)]
#[derive(Copy)]
pub struct _RFC_METADATA_QUERY_RESULT_ENTRY {
    pub name: RFC_ABAP_NAME,
    pub errorMessage: [SAP_UC; 512usize],
}
#[test]
fn bindgen_test_layout__RFC_METADATA_QUERY_RESULT_ENTRY() {
    assert_eq!(::std::mem::size_of::<_RFC_METADATA_QUERY_RESULT_ENTRY>() ,
               543usize , concat ! (
               "Size of: " , stringify ! ( _RFC_METADATA_QUERY_RESULT_ENTRY )
               ));
    assert_eq! (::std::mem::align_of::<_RFC_METADATA_QUERY_RESULT_ENTRY>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                _RFC_METADATA_QUERY_RESULT_ENTRY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_METADATA_QUERY_RESULT_ENTRY ) ) .
                name as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_METADATA_QUERY_RESULT_ENTRY ) , "::" , stringify ! ( name
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _RFC_METADATA_QUERY_RESULT_ENTRY ) ) .
                errorMessage as * const _ as usize } , 31usize , concat ! (
                "Alignment of field: " , stringify ! (
                _RFC_METADATA_QUERY_RESULT_ENTRY ) , "::" , stringify ! (
                errorMessage ) ));
}
impl Clone for _RFC_METADATA_QUERY_RESULT_ENTRY {
    fn clone(&self) -> Self { *self }
}
impl Default for _RFC_METADATA_QUERY_RESULT_ENTRY {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RFC_METADATA_QUERY_RESULT_ENTRY = _RFC_METADATA_QUERY_RESULT_ENTRY;
#[repr(u32)]
/// \enum _RFC_METADATA_OBJ_TYPE
/// \ingroup repository
///
/// An RFC_METADATA_OBJ_TYPE indicates whether in a call to RfcGetMetadataQueryFailedEntry() or RfcGetMetadataQuerySucceededEntry()
/// you are interested in the error/success message for a function module (_FUNCTION), structure/table (_TYPE) or ABAP Class (_CLASS).
/// It needs to be passed to the above two functions.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _RFC_METADATA_OBJ_TYPE {
    RFC_METADATA_FUNCTION = 0,
    RFC_METADATA_TYPE = 1,
    RFC_METADATA_CLASS = 2,
}
pub use self::_RFC_METADATA_OBJ_TYPE as RFC_METADATA_OBJ_TYPE;
extern "C" {
    /// \brief  Creates the metadata query result
/// \ingroup repository
///
/// Metadata query results contain the names of functions, types and classes queried successfully, and the corresponding
/// errors, if the query failed.
///
/// \out *errorInfo More details in error case
/// \return Handle to a metadata query result
    pub fn RfcCreateMetadataQueryResult(errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_METADATA_QUERY_RESULT_HANDLE;
}
extern "C" {
    /// \brief  Destroys the metadata query result
/// \ingroup repository
///
/// Releases all resources allocated by the metadata query result.
///
/// \in handle Handle to a metadata query result
/// \out *errorInfo More details in error case
/// \return RFC_RC
    pub fn RfcDestroyMetadataQueryResult(handle:
                                             RFC_METADATA_QUERY_RESULT_HANDLE,
                                         errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Describes the metadata query result
/// \ingroup repository
///
/// Returns the number of succeeded and failed entries in the metadata query result. The entries' content can be read with
/// RfcGetMetadataQueryFailedEntry() and RfcGetMetadataQuerySucceededEntry().
///
/// \in handle Handle to a metadata query result
/// \in type Type of the metadata objects you are interested in
/// \out *successful Number of metadata objects queried successfully
/// \out *failed Number of metadata objects that could not be queried
/// \out *errorInfo More details in error case
/// \return RFC_RC
    pub fn RfcDescribeMetadataQueryResult(handle:
                                              RFC_METADATA_QUERY_RESULT_HANDLE,
                                          type_: RFC_METADATA_OBJ_TYPE,
                                          successful:
                                              *mut ::std::os::raw::c_uint,
                                          failed: *mut ::std::os::raw::c_uint,
                                          errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Returns the error entry from the metadata query result
/// \ingroup repository
///
/// Returns the object name and the error text, if an error occurred during the query.
///
/// \in handle Handle to a metadata query result
/// \in type Type of the requested object
/// \in index Index of the requested object. Must be between 0 and "failed - 1", where "failed" is the value
/// returned from RfcDescribeMetadataQueryResult() for the given RFC_METADATA_OBJ_TYPE.
/// \inout *entry Pointer to the allocated structure to store the name of the metadata object and the error text
/// \out *errorInfo More details in error case
/// \return RFC_RC
    pub fn RfcGetMetadataQueryFailedEntry(handle:
                                              RFC_METADATA_QUERY_RESULT_HANDLE,
                                          type_: RFC_METADATA_OBJ_TYPE,
                                          index: ::std::os::raw::c_uint,
                                          entry:
                                              *mut RFC_METADATA_QUERY_RESULT_ENTRY,
                                          errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Returns a succeeded entry from the metadata query result
/// \ingroup repository
///
/// Returns the object name of a successfully queried object.
///
/// \in handle Handle to a metadata query result
/// \in type Type of the requested object
/// \in index Index of the requested object. Must be between 0 and "successful - 1", where "successful" is the value
/// returned from RfcDescribeMetadataQueryResult() for the given RFC_METADATA_OBJ_TYPE.
/// \inout *succeedObj Pointer to the allocated buffer to store the name of the metadata object
/// \out *errorInfo More details in error case
/// \return RFC_RC
    pub fn RfcGetMetadataQuerySucceededEntry(handle:
                                                 RFC_METADATA_QUERY_RESULT_HANDLE,
                                             type_: RFC_METADATA_OBJ_TYPE,
                                             index: ::std::os::raw::c_uint,
                                             succeedObj: *mut RFC_CHAR,
                                             errorInfo: *mut RFC_ERROR_INFO)
     -> RFC_RC;
}
extern "C" {
    /// \brief  Queries the meta data for function, type and class lists.
/// \ingroup repository
///
/// Queries the meta data for function, type and class lists. All meta data is fetched using one roundtrip,
/// the result is cached in the repository cache.
///
/// \note You can use this feature only, if your backend system supports it. SAP Note 1456826 describes the
/// required minimum support package level that the backend system must have. If the backend system supports
/// it, open the RFC_CONNECTION_HANDLE with the additional logon parameter USE_REPOSITORY_ROUNDTRIP_OPTIMIZATION=1,
/// before you pass it to %RfcMetadataBatchQuery().
///
/// \in rfcHandle Open client connection to the R/3 System, for which you need the function module, type or class descriptions.
/// \in *functionNames Names of the function modules to look up
/// \in functionCount Length of the function name list
/// \in *typeNames Names of the types (structures and tables) to look up
/// \in typeCount Length of the type name list
/// \in *classNames Names of the classes to look up
/// \in classCount Length of the class name list
/// \in handle Query result, may be null
/// \out *errorInfo More error details in case something goes wrong
/// \return RFC_RC
    pub fn RfcMetadataBatchQuery(rfcHandle: RFC_CONNECTION_HANDLE,
                                 functionNames: *mut *const SAP_UC,
                                 functionCount: ::std::os::raw::c_uint,
                                 typeNames: *mut *const SAP_UC,
                                 typeCount: ::std::os::raw::c_uint,
                                 classNames: *mut *const SAP_UC,
                                 classCount: ::std::os::raw::c_uint,
                                 handle: RFC_METADATA_QUERY_RESULT_HANDLE,
                                 errorInfo: *mut RFC_ERROR_INFO) -> RFC_RC;
}
